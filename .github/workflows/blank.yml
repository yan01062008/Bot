import asyncio, time, os

try:
    os.nice(5)
except Exception:
    pass

class RateLimiter:
    def __init__(self, max_rate_per_sec: float = 6.0):
        self.max_rate = max_rate_per_sec
        self.tokens = max_rate_per_sec
        self.last_time = time.monotonic()

    async def acquire(self, cost: float = 1.0):
        now = time.monotonic()
        elapsed = now - self.last_time
        self.last_time = now
        self.tokens = min(self.max_rate, self.tokens + elapsed * self.max_rate)
        if self.tokens < cost:
            wait = (cost - self.tokens) / self.max_rate
            await asyncio.sleep(wait)
            self.tokens = 0
        else:
            self.tokens -= cost

async def cooperative_sleep(i, every=10, delay=0.02):
    if i % every == 0:
        await asyncio.sleep(delay)

SEMAPHORE = asyncio.Semaphore(3)
GLOBAL_LIMITER = RateLimiter(max_rate_per_sec=8)

import os
import sys
import shutil
import platform
import zipfile
import tarfile
import requests


BASE_DIR = os.path.abspath("ffmpeg")
os.makedirs(BASE_DIR, exist_ok=True)

SYSTEM = platform.system().lower()

if SYSTEM == "windows":
    FFMPEG_PATH = os.path.join(BASE_DIR, "ffmpeg.exe")
else:
    FFMPEG_PATH = os.path.join(BASE_DIR, "ffmpeg")

def install_ffmpeg():
    if os.path.exists(FFMPEG_PATH):
        print(f"[FFMPEG] ‚úî ƒê√£ t·ªìn t·∫°i: {FFMPEG_PATH}")
        return True

    print("[FFMPEG] ‚úñ Ch∆∞a c√≥ ‚Äì ƒëang t·∫£i ffmpeg...")

    try:
        if SYSTEM == "windows":
            url = "https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-essentials.zip"
            zip_path = os.path.join(BASE_DIR, "ffmpeg.zip")

            with requests.get(url, stream=True, timeout=60) as r:
                r.raise_for_status()
                with open(zip_path, "wb") as f:
                    for chunk in r.iter_content(8192):
                        f.write(chunk)

            with zipfile.ZipFile(zip_path, "r") as z:
                z.extractall(BASE_DIR)

            for root, _, files in os.walk(BASE_DIR):
                if "ffmpeg.exe" in files:
                    shutil.copy(
                        os.path.join(root, "ffmpeg.exe"),
                        FFMPEG_PATH
                    )
                    print("[FFMPEG] ‚úî C√†i xong (Windows)")
                    return True

        else:
            url = "https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-amd64-static.tar.xz"
            tar_path = os.path.join(BASE_DIR, "ffmpeg.tar.xz")

            with requests.get(url, stream=True, timeout=60) as r:
                r.raise_for_status()
                with open(tar_path, "wb") as f:
                    for chunk in r.iter_content(8192):
                        f.write(chunk)

            with tarfile.open(tar_path, "r:xz") as t:
                t.extractall(BASE_DIR)

            for root, _, files in os.walk(BASE_DIR):
                if "ffmpeg" in files:
                    src = os.path.join(root, "ffmpeg")
                    shutil.copy(src, FFMPEG_PATH)
                    os.chmod(FFMPEG_PATH, 0o755)
                    print("[FFMPEG] ‚úî C√†i xong (Linux)")
                    return True

    except Exception as e:
        print("[FFMPEG] ‚ùå L·ªói:", e)
        return False

    return False


if not install_ffmpeg():
    print("[SYSTEM] ‚ùå Kh√¥ng c√†i ƒë∆∞·ª£c FFmpeg ‚Üí Tho√°t")
    sys.exit(1)

print(f"[SYSTEM] ‚úî FFmpeg s·∫µn s√†ng: {FFMPEG_PATH}\n")

import discord
from discord.ext import commands
from discord.ext.commands import guild_only
from discord.ui import Button, View, Modal, TextInput
import threading
import asyncio
import time
import random
import re
import json
import requests
import os
import string
import datetime
import subprocess
from module.raid import *
from module.utils import *
from module.nhaytagmqtt import *
from module.typingmqtt import *
from discord.ext import tasks
import gc
from module.treomqtt import *
from module.nhaypoll import *
from module.nenMqtt import *
from module.treosharecontactMqtt import *
from module.treosharelinkMqtt import *
from module.nhaynamebox import *
import hashlib
from module.username import *

intents = discord.Intents.all()
DEVNULL = open(os.devnull, 'w')
VOICE_SESSIONS = {}
MUSIC_FOLDER = "music"
os.makedirs(MUSIC_FOLDER, exist_ok=True)
DISCORD_API = "https://discord.com/api/v10"
snipe_data = {}
start_time = time.time()
running_tasks = {}
STK = "9225689689"
TEN_CHUTK = "VU ANH DUC"
QR_FIXED_URL = "https://cdn.discordapp.com/attachments/1439082738345967686/1453393007482109994/486166056_961147052805108_7574170735150141407_n.png?ex=69718a77&is=697038f7&hm=1315b8cc21032ce4c13eb113d0d8d2eae4cf57b1ae03edebcc9bb36c66827ad1&"
EMOJI_LIST = ["üî•", "üíÄ", "ü§°", "üëπ", "üéØ", "üíé", "üåü", "üöÄ", "‚ò£Ô∏è", "üè¥‚Äç‚ò†Ô∏è", "üñï", "‚ö†Ô∏è", "üßø", "‚ö°", "üßß", "üßä", "üé≠","üê∑","üòè","üëè","üí•","üòÉ","üò≠","üôè","üí©","üòà"]
THUMBNAIL_URL = "https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&"
FFMPEG_OPTIONS = {
    "before_options": "-nostdin -loglevel error -analyzeduration 0 -probesize 32",
    "options": "-vn",
    "executable": "ffmpeg"
}
ACTION_GIFS = {
    "hug": [
        "https://media.giphy.com/media/l2QDM9Jnim1YVILXa/giphy.gif",
        "https://media.giphy.com/media/od5H3PmEG5EVq/giphy.gif",
        "https://media.giphy.com/media/49mdjsMrH7oze/giphy.gif",
        "https://media.giphy.com/media/svXXBgduBsJ1u/giphy.gif",
        "https://media.giphy.com/media/HaC1WdpkL3W00/giphy.gif"
    ],
    "slap": [
        "https://media.giphy.com/media/jLeyZWgtwgr2U/giphy.gif",
        "https://media.giphy.com/media/Gf3AUz3eBNbTW/giphy.gif",
        "https://media.giphy.com/media/Zau0yrl17uzdK/giphy.gif",
        "https://media.giphy.com/media/mEtSQlxqBtWWA/giphy.gif",
        "https://media.giphy.com/media/3XlEk2RxPS1m8/giphy.gif"
    ],
    "kill": [
        "https://cdn.discordapp.com/attachments/1455376854826614920/1471005073990484062/kill.gif?ex=698d5bbb&is=698c0a3b&hm=604d7d92a0e095b93f026a538a9b87f5096958151a138a21e282ce6d22998d69&",
        "https://cdn.discordapp.com/attachments/1455376854826614920/1471005074322096201/kill2.gif?ex=698d5bbb&is=698c0a3b&hm=69c572573b62c7b9305e045b674f9a093340cd435e17f91eb90fece1fdba5430&",
        "https://cdn.discordapp.com/attachments/1455376854826614920/1471005153879658598/kill3.gif?ex=698d5bce&is=698c0a4e&hm=d66268b582624237a35e8d6e6e4da106edf14cc5d6375452d79a796726053cd6&",
        "https://cdn.discordapp.com/attachments/1455376854826614920/1471005215317561487/kill5.gif?ex=698d5bdd&is=698c0a5d&hm=2f28fd0b9b1dce68208d95ca8e39604c8ea0ff5acb0e9857b99b51595571d60d&",
        "https://cdn.discordapp.com/attachments/1455376854826614920/1471005215783260403/kill6.gif?ex=698d5bdd&is=698c0a5d&hm=7356146c5c26b431e7a7205c2ccca3207a63f31642e552b5b4e585c06f8e82b2&"
    ],
    "kiss": [
        "https://media.giphy.com/media/FqBTvSNjNzeZG/giphy.gif",
        "https://media.giphy.com/media/bGm9FuBCGg4SY/giphy.gif",
        "https://media.giphy.com/media/G3va31oEEnIkM/giphy.gif",
        "https://media.giphy.com/media/KH1CTZtw1iP3W/giphy.gif"
    ]
}
ACTION_TEXT = {
    "hug": [
        "√¥m {user} th·∫≠t ch·∫∑t v√†o l√≤ng, nh∆∞ s·ª£ ng∆∞·ªùi ta bi·∫øn m·∫•t gi·ªØa th·∫ø gi·ªõi r·ªông l·ªõn n√†y üíû",
        "nh·∫π nh√†ng v√≤ng tay qua vai {user}, trao m·ªôt c√°i √¥m ·∫•m √°p ƒë·∫ßy y√™u th∆∞∆°ng ü§ó",
        "ch·∫°y ƒë·∫øn v√† √¥m ch·∫ßm l·∫•y {user}, gi·ªØ th·∫≠t l√¢u kh√¥ng bu√¥ng üíó",
        "k√©o {user} v√†o l√≤ng v√† th√¨ th·∫ßm v√†i ƒëi·ªÅu ng·ªçt ng√†o ch·ªâ hai ng∆∞·ªùi nghe th·∫•y üíï"
    ],
    "slap": [
        "gi√°ng cho {user} m·ªôt c√∫ t√°t vang tr·ªùi khi·∫øn kh√¥ng kh√≠ ƒë√¥ng c·ª©ng l·∫°i üëãüí•",
        "b·∫•t ng·ªù quay sang v√† t√°t {user} c√°i 'b·ªëp' ƒë·∫ßy uy l·ª±c üò§",
        "kh√¥ng n√≥i kh√¥ng r·∫±ng, cho {user} m·ªôt c√∫ tr·ªùi gi√°ng üî•"
    ],
    "kill": [
        "√¢m th·∫ßm ti·∫øp c·∫≠n r·ªìi k·∫øt li·ªÖu {user} trong b√≥ng t·ªëi l·∫°nh l·∫Ωo üåëüî™",
        "ra tay d·ª©t kho√°t, kh√¥ng cho {user} c∆° h·ªôi ph·∫£n kh√°ng üíÄ",
        "nh√¨n {user} l·∫ßn cu·ªëi r·ªìi ti·ªÖn ƒëi kh√¥ng l·ªùi t·ª´ bi·ªát..."
    ],
    "kiss": [
        "nh·∫π nh√†ng n√¢ng c·∫±m {user} l√™n v√† trao m·ªôt n·ª• h√¥n n·ªìng ch√°y üíã",
        "k√©o {user} l·∫°i g·∫ßn v√† ƒë·∫∑t l√™n m√¥i m·ªôt n·ª• h√¥n ƒë·∫ßy c·∫£m x√∫c üòò",
        "h√¥n {user} say ƒë·∫Øm nh∆∞ th·ªÉ th·∫ø gi·ªõi ch·ªâ c√≤n hai ng∆∞·ªùi üíû"
    ]
}

def guild_only():
    def predicate(ctx):
        return ctx.guild is not None
    return commands.check(predicate)

def load_config():
    if os.path.exists('config.json'):
        with open('config.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    return None

def save_config(config):
    with open('config.json', 'w', encoding='utf-8') as f:
        json.dump(config, f, ensure_ascii=False, indent=4)

def create_initial_config():
    token = input("Nh·∫≠p Token Bot Discord C·ªßa B·∫°n > ")
    owner_id = input("Nh·∫≠p Owner ID > ")
    prefix = input("Nh·∫≠p Prefix Cho Bot > ")
    
    config = {
        "tokenbot": token,
        "prefix": prefix,
        "ownerVIP": owner_id,
        "ownerID": [owner_id]
    }
    
    save_config(config)
    return config

config_data = load_config()
if config_data:
    choice = input("B·∫°n C√≥ Mu·ªën S·ª≠ D·ª•ng L·∫°i Token V√† Owner ID V√† Prefix C≈© Kh√¥ng (Y/N) > ").lower()
    if choice != 'y':
        config_data = create_initial_config()
else:
    config_data = create_initial_config()

config = {
    'ownerVIP': config_data['ownerVIP'],
    'ownerID': config_data['ownerID'],
}

bot = commands.Bot(command_prefix=config_data['prefix'], intents=intents)
active_senders = {}

if not os.path.exists('data'):
    os.makedirs('data')

# Ki·ªÉm tra quy·ªÅn d√πng l·ªánh d·ª±a tr√™n user_id
def can_use_commands(user_id):
    user_id_str = str(user_id)

    # Ch·ªß bot th√¨ lu√¥n c√≥ quy·ªÅn
    if user_id_str in config['ownerID']:
        return True, "Owner access"

    # N·∫øu user c√≥ tasks
    user_tasks = load_user_tasks()
    if user_id_str in user_tasks and user_tasks[user_id_str] > 0:
        return True, "User has tasks"

    # N·∫øu kh√¥ng tho·∫£ m√£n ƒëi·ªÅu ki·ªán n√†o
    return False, "No permission"
    
    return False, "No permission"

def can_create_task(user_id):
    can_use, reason = can_use_commands(user_id)
    if not can_use:
        return False, reason
    return check_user_task_limit(user_id)
def load_user_tasks():
    """Load user task limits from file"""
    try:
        with open('user_tasks.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return {}
    except Exception:
        return {}

def save_user_tasks(user_tasks):
    """Save user task limits to file"""
    with open('user_tasks.json', 'w', encoding='utf-8') as f:
        json.dump(user_tasks, f, ensure_ascii=False, indent=4)

def get_user_task_count(user_id):
    """Get current task count for a user"""
    if not os.path.exists('data'):
        return 0
    
    task_count = 0
    for folder in os.listdir('data'):
        folder_path = f"data/{folder}"
        if os.path.isdir(folder_path) and os.path.exists(f"{folder_path}/luutru.txt"):
            try:
                with open(f"{folder_path}/luutru.txt", "r", encoding="utf-8") as f:
                    content = f.read().strip()
                    parts = content.split(" | ")
                    if len(parts) >= 5 and parts[4] == str(user_id):
                        task_count += 1
            except:
                continue
    
    return task_count

def check_user_task_limit(user_id):
    """Check if user can create more tasks"""
    user_tasks = load_user_tasks()
    user_id_str = str(user_id)
    
    # N·∫øu user l√† owner VIP th√¨ kh√¥ng gi·ªõi h·∫°n
    if user_id_str in config['ownerID']:
        return True, "Unlimited"
    
    # N·∫øu user kh√¥ng c√≥ trong danh s√°ch th√¨ kh√¥ng ƒë∆∞·ª£c t·∫°o task
    if user_id_str not in user_tasks:
        return False, "No tasks available"
    
    current_tasks = get_user_task_count(user_id)
    max_tasks = user_tasks[user_id_str]
    
    return current_tasks < max_tasks, f"{current_tasks}/{max_tasks}"

def load_user_list():
    try:
        with open('users.txt', 'r', encoding='utf-8') as f:
            user_list = [line.strip() for line in f.readlines() if line.strip()]
            if not user_list:
                default_users = ["100066425450746"]
                with open('users.txt', 'w', encoding='utf-8') as f:
                    f.write('\n'.join(default_users))
                return default_users
            return user_list
    except FileNotFoundError:
        default_users = ["100066425450746"]
        with open('users.txt', 'w', encoding='utf-8') as f:
            f.write('\n'.join(default_users))
        return default_users
    except Exception:
        return ["100066425450746"]

def safe_thread_wrapper(func, *args):
    try:
        func(*args)
    except Exception:
        folder_name = args[-1] if args else "unknown"
        folder_path = os.path.join("data", folder_name)
        if os.path.exists(folder_path):
            import shutil
            shutil.rmtree(folder_path)

def load_messages_from_file():
    try:
        with open('ngon.txt', 'r', encoding='utf-8') as f:
            messages = [line.strip() for line in f.readlines() if line.strip()]
            return messages
    except FileNotFoundError:
        default_messages = ["Tin nh·∫Øn m·∫∑c ƒë·ªãnh", "Hello world", "Test message", "Xin ch√†o", "Ahihi"]
        with open('ngon.txt', 'w', encoding='utf-8') as f:
            f.write('\n'.join(default_messages))
        return default_messages
    except Exception:
        return ["Tin nh·∫Øn m·∫∑c ƒë·ªãnh", "Hello world", "Test message"]

def load_so_messages_from_file():
    try:
        with open('so.txt', 'r', encoding='utf-8') as f:
            messages = [line.strip() for line in f.readlines() if line.strip()]
            return messages
    except FileNotFoundError:
        default_messages = ["Tin nh·∫Øn treeso m·∫∑c ƒë·ªãnh", "So message 1", "So message 2", "N·ªôi dung treoso", "Test treoso"]
        with open('so.txt', 'w', encoding='utf-8') as f:
            f.write('\n'.join(default_messages))
        return default_messages
    except Exception:
        return ["Tin nh·∫Øn treoso m·∫∑c ƒë·ªãnh", "So message", "Test treoso"]

def getUserInformation(dataFB, userID):
    dataForm = formAll(dataFB, requireGraphql=False)
    dataForm["ids[0]"] = userID
    
    mainRequests = {
        "headers": Headers(dataFB["cookieFacebook"], dataForm),
        "timeout": 5,
        "url": "https://www.facebook.com/chat/user_info/",
        "data": dataForm,
        "cookies": parse_cookie_string(dataFB["cookieFacebook"]),
        "verify": True
    }
    
    try:
        sendRequests = requests.post(**mainRequests)
        jsonData = json.loads(sendRequests.text.split("for (;;);")[1])["payload"]["profiles"][str(userID)]
        
        idUser = jsonData.get("id")
        nameUser = jsonData.get("name")
        firstName = jsonData.get("firstName")
        Username = jsonData.get("vanity")
        thumbSrc = jsonData.get("thumnSrc")
        urlProfile = jsonData.get("uri")
        genderUser = jsonData.get("gender")
        alternateName = jsonData.get("alternateName")
        chatWithUSerIsNonFriend = jsonData.get("is_nonfriend_messenger_contact")
        
        if (genderUser == 1): genderUser = "Female (N·ªØ)"
        elif (genderUser == 2): genderUser = "Male (Nam)"
        else: genderUser = "Unknown (Kh√¥ng x√°c ƒë·ªãnh)"
        
        return {
            "idUser": idUser,
            "nameUser": nameUser,
            "firstName": firstName,
            "Username": Username,
            "thumbSrc": thumbSrc,
            "urlProfile": urlProfile,
            "genderUser": genderUser,
            "alternateName": alternateName,
            "chatWithUSerIsNonFriend": chatWithUSerIsNonFriend
        }
    except:
        return {"err": 0}

def send_msg(token, channel_id, message):
    try:
        headers = {
            'Authorization': token,
            'Content-Type': 'application/json'
        }
        payload = {
            'content': message
        }
        url = f'https://discord.com/api/v10/channels/{channel_id}/messages'
        response = requests.post(url, headers=headers, json=payload, timeout=10)
        
        print(f"Send Message - Status: {response.status_code}")
        if response.status_code not in [200, 201]:
            print(f"Error response: {response.text}")
        
        return response.status_code
    except Exception as e:
        print(f"Error sending message: {e}")
        return None

def faketyping_discord(token, channel_id):
    try:
        headers = {
            'Authorization': token,
            'Content-Type': 'application/json'
        }
        url = f'https://discord.com/api/v10/channels/{channel_id}/typing'
        response = requests.post(url, headers=headers, timeout=10)
        
        return response.status_code
    except Exception as e:
        print(f"Error sending typing: {e}")
        return None

def build_auth_header(token: str):
    token = token.strip()
    if token.lower().startswith("bot "):
        return token   
    return token      

def parse_delay(value, default=5.0):
    try:
        return float(value.strip())
    except:
        return default

class FacebookMessageSender:
    def __init__(self, cookies: str):
        self.cookies = cookies
        self.message_client = None
        self.typing_client = None
        self.typing_thread = None
        self.is_running = False
        self.current_thread_id = None

    def connect(self):
        self.message_client = FacebookMQTTClient(self.cookies)
        self.message_client.connect()
        self.typing_client = FacebookTypingMQTT(self.cookies)
        self.typing_client.connect()

    def start_continuous_typing(self, thread_id: str):
        self.current_thread_id = thread_id
        self.is_running = True
        
        def typing_loop():
            while self.is_running:
                try:
                    self.typing_client.send_typing_indicator(thread_id, True)
                    time.sleep(random.uniform(2.0, 4.0))
                except Exception:
                    time.sleep(1)
        
        self.typing_thread = threading.Thread(target=typing_loop, daemon=True)
        self.typing_thread.start()

    def stop_continuous_typing(self):
        if self.is_running:
            self.is_running = False
            if self.current_thread_id:
                try:
                    self.typing_client.send_typing_indicator(self.current_thread_id, False)
                except:
                    pass

    def send_message(self, text: str, mention_data: dict, thread_id: str):
        self.message_client.send_message(
            text=text,
            mention=mention_data,
            thread_id=thread_id
        )

    def send_simple_message(self, text: str, thread_id: str):
        self.message_client.send_message(
            text=text,
            mention={},
            thread_id=thread_id
        )

    def disconnect(self):
        self.stop_continuous_typing()
        if self.message_client:
            self.message_client.disconnect()
        if self.typing_client:
            self.typing_client.disconnect()

# ===== C√ÅC H√ÄM TASK =====
async def safe_send(interaction: discord.Interaction, message: str, ephemeral: bool = True):
    """G·ª≠i tin nh·∫Øn an to√†n (tr√°nh l·ªói Unknown Interaction)"""
    try:
        if not interaction.response.is_done():
            await interaction.response.send_message(message, ephemeral=ephemeral)
        else:
            await interaction.followup.send(message, ephemeral=ephemeral)
    except discord.NotFound:
        print("[WARN] Interaction expired")

def start_nhay_tag_everyone_discord_func(tokens, channel_id, delay_str, folder_name):
    delay = float(delay_str)
    folder_path = os.path.join("data", folder_name)
    
    token_list = [token.strip() for token in tokens.split('\n') if token.strip()]
    valid_tokens = []
    
    running = True
    while running:
        try:
            folder_path = os.path.join("data", folder_name)
            if not os.path.exists(folder_path):
                running = False
                break
            
            for token in token_list:
                if token not in valid_tokens:
                    status = faketyping_discord(token, channel_id)
                    if status in [200, 201, 204]:
                        valid_tokens.append(token)
                    elif status in [400, 401, 403]:
                        continue
            
            current_dir = os.path.dirname(os.path.abspath(__file__))
            nhay_path = os.path.join(current_dir, "nhaydis.txt")
            
            if not os.path.exists(nhay_path):
                with open(nhay_path, "w", encoding="utf-8") as f:
                    f.write("cay ak\ncn choa\nsua em\nsua de\nmanh em\ncay ak\ncn nqu")
            
            with open(nhay_path, "r", encoding="utf-8") as f:
                lines = f.readlines()
            
            for line in lines:
                folder_path = os.path.join("data", folder_name)
                if not os.path.exists(folder_path):
                    running = False
                    break
                
                msg = line.strip()
                if msg:
                    for token in valid_tokens:
                        faketyping_discord(token, channel_id)
                        time.sleep(1)
                        
                        import random
                        mention_text = random.choice(["@everyone","@here"])
                        tagged_msg = f"{msg} {mention_text}"
                        send_msg(token, channel_id, tagged_msg)
                        time.sleep(delay)
                        
        except Exception as e:
            print(f"Error in nhay tag discord: {e}")
            time.sleep(10)

def start_nhay_emoji_discord_func(tokens, channel_id, delay_str, folder_name):
    delay = float(delay_str)
    token_list = [token.strip() for token in tokens.split('\n') if token.strip()]
    valid_tokens = []

    running = True
    while running:
        try:
            folder_path = os.path.join("data", folder_name)
            if not os.path.exists(folder_path):
                break

            for token in token_list:
                if token not in valid_tokens:
                    status = faketyping_discord(token, channel_id)
                    if status in [200, 201, 204]:
                        valid_tokens.append(token)
                    elif status in [400, 401, 403]:
                        continue

            for token in valid_tokens:
                if not os.path.exists(folder_path):
                    running = False
                    break

                faketyping_discord(token, channel_id)
                time.sleep(1)

                msg = "".join(
                    random.choices(
                        EMOJI_LIST,
                        k=random.randint(3, 7)
                    )
                )

                send_msg(token, channel_id, msg)
                time.sleep(delay)

        except Exception as e:
            print("Error nhay emoji discord:", e)
            time.sleep(10)

def start_treo_discord_func(tokens, channel_id, message, delay_str, folder_name):
    delay = float(delay_str)
    folder_path = os.path.join("data", folder_name)
    
    token_list = [token.strip() for token in tokens.split('\n') if token.strip()]
    valid_tokens = []
    
    running = True
    while running:
        try:
            folder_path = os.path.join("data", folder_name)
            if not os.path.exists(folder_path):
                running = False
                break
            
            for token in token_list:
                if token not in valid_tokens:
                    status = faketyping_discord(token, channel_id)  #check stat√∫e
                    if status in [200, 201, 204]:
                        valid_tokens.append(token)
                    elif status in [400, 401, 403]:
                        continue
            
            for token in valid_tokens:
                folder_path = os.path.join("data", folder_name)
                if not os.path.exists(folder_path):
                    running = False
                    break
                
                
                send_msg(token, channel_id, message)
                time.sleep(delay)
                
        except Exception as e:
            print(f"Error in treo discord: {e}")
            time.sleep(10)

def start_nhay_discord_func(tokens, channel_id, delay_str, folder_name):
    delay = float(delay_str)
    folder_path = os.path.join("data", folder_name)
    
    token_list = [token.strip() for token in tokens.split('\n') if token.strip()]
    valid_tokens = []
    
    running = True
    while running:
        try:
            folder_path = os.path.join("data", folder_name)
            if not os.path.exists(folder_path):
                running = False
                break
            
            for token in token_list:
                if token not in valid_tokens:
                    status = faketyping_discord(token, channel_id)
                    if status in [200, 201, 204]:
                        valid_tokens.append(token)
                    elif status in [400, 401, 403]:
                        continue
            
            current_dir = os.path.dirname(os.path.abspath(__file__))
            nhay_path = os.path.join(current_dir, "nhay.txt")
            
            if not os.path.exists(nhay_path):
                with open(nhay_path, "w", encoding="utf-8") as f:
                    f.write("cay ak\ncn choa\nsua em\nsua de\nmanh em\ncay ak\ncn nqu")
            
            with open(nhay_path, "r", encoding="utf-8") as f:
                lines = f.readlines()
            
            for line in lines:
                folder_path = os.path.join("data", folder_name)
                if not os.path.exists(folder_path):
                    running = False
                    break
                
                msg = line.strip()
                if msg:
                    for token in valid_tokens:
                        faketyping_discord(token, channel_id)
                        time.sleep(1)
                        send_msg(token, channel_id, msg)
                        time.sleep(delay)
                        
        except Exception as e:
            print(f"Error in nhay discord: {e}")
            time.sleep(10)


def start_nhay_tag_discord_func(tokens, channel_id, uid_mention, delay_str, folder_name):
    delay = float(delay_str)
    folder_path = os.path.join("data", folder_name)
    
    token_list = [token.strip() for token in tokens.split('\n') if token.strip()]
    valid_tokens = []
    
    running = True
    while running:
        try:
            folder_path = os.path.join("data", folder_name)
            if not os.path.exists(folder_path):
                running = False
                break
            
            for token in token_list:
                if token not in valid_tokens:
                    status = faketyping_discord(token, channel_id)
                    if status in [200, 201, 204]:
                        valid_tokens.append(token)
                    elif status in [400, 401, 403]:
                        continue
            
            current_dir = os.path.dirname(os.path.abspath(__file__))
            nhay_path = os.path.join(current_dir, "nhay.txt")
            
            if not os.path.exists(nhay_path):
                with open(nhay_path, "w", encoding="utf-8") as f:
                    f.write("cay ak\ncn choa\nsua em\nsua de\nmanh em\ncay ak\ncn nqu")
            
            with open(nhay_path, "r", encoding="utf-8") as f:
                lines = f.readlines()
            
            for line in lines:
                folder_path = os.path.join("data", folder_name)
                if not os.path.exists(folder_path):
                    running = False
                    break
                
                msg = line.strip()
                if msg:
                    for token in valid_tokens:
                        faketyping_discord(token, channel_id)
                        time.sleep(1)
                        
                        import random
                        tagged_msg = random.choice([f"{msg} <@{uid_mention}>", f"<@{uid_mention}> {msg}"])
                        send_msg(token, channel_id, tagged_msg)
                        time.sleep(delay)
                        
        except Exception as e:
            print(f"Error in nhay tag discord: {e}")
            time.sleep(10)

def start_so_discord_nhay_func(tokens, channel_id, delay_str, folder_name):
    import os, time, random

    delay = float(delay_str)
    so_path = os.path.join(os.path.dirname(__file__), "so.txt")

    token_list = [t.strip() for t in tokens.split('\n') if t.strip()]
    valid_tokens = []

    running = True
    while running:
        try:
            # check stop
            if not os.path.exists(os.path.join("data", folder_name)):
                break

            # check token s·ªëng
            for token in token_list:
                if token not in valid_tokens:
                    status = faketyping_discord(token, channel_id)
                    if status in [200, 201, 204]:
                        valid_tokens.append(token)

            if not os.path.exists(so_path):
                time.sleep(delay)
                continue

            with open(so_path, "r", encoding="utf-8") as f:
                lines = [x.strip() for x in f if x.strip()]

            if not lines:
                time.sleep(delay)
                continue

            msg = random.choice(lines)

            for token in valid_tokens:
                if not os.path.exists(os.path.join("data", folder_name)):
                    running = False
                    break

                faketyping_discord(token, channel_id)
                time.sleep(1)
                send_msg(token, channel_id, msg)
                time.sleep(delay)

        except Exception as e:
            print(f"[SO NHAY ERROR] {e}")
            time.sleep(10)

def start_so_tag_func(tokens, channel_id, uid_mention, delay_str, folder_name):
    import os, time, random

    delay = float(delay_str)
    so_path = os.path.join(os.path.dirname(__file__), "so.txt")

    token_list = [t.strip() for t in tokens.split('\n') if t.strip()]
    valid_tokens = []

    running = True
    while running:
        try:
            if not os.path.exists(os.path.join("data", folder_name)):
                break

            for token in token_list:
                if token not in valid_tokens:
                    status = faketyping_discord(token, channel_id)
                    if status in [200, 201, 204]:
                        valid_tokens.append(token)

            if not os.path.exists(so_path):
                time.sleep(delay)
                continue

            with open(so_path, "r", encoding="utf-8") as f:
                lines = [x.strip() for x in f if x.strip()]

            if not lines:
                time.sleep(delay)
                continue

            msg = random.choice(lines)

            for token in valid_tokens:
                if not os.path.exists(os.path.join("data", folder_name)):
                    running = False
                    break

                faketyping_discord(token, channel_id)
                time.sleep(1)

                tagged_msg = random.choice([
                    f"{msg} <@{uid_mention}>",
                    f"<@{uid_mention}> {msg}"
                ])

                send_msg(token, channel_id, tagged_msg)
                time.sleep(delay)

        except Exception as e:
            print(f"[SO TAG NHAY ERROR] {e}")
            time.sleep(10)

def start_poll_discord_nhay_func(tokens, channel_id, delay_str, folder_name):
    import os, time, random, requests

    delay = float(delay_str)

    token_list = [t.strip() for t in tokens.split('\n') if t.strip()]
    valid_tokens = []

    nhay_path = os.path.join(os.path.dirname(__file__), "nhay.txt")

    if not os.path.exists(nhay_path):
        print("[POLL NHAY] Kh√¥ng t√¨m th·∫•y nhay.txt")
        return

    with open(nhay_path, "r", encoding="utf-8") as f:
        lines = [l.strip() for l in f if l.strip()]

    if len(lines) < 11:
        print("[POLL NHAY] nhay.txt c·∫ßn √≠t nh·∫•t 11 d√≤ng")
        return

    url = f"https://discord.com/api/v10/channels/{channel_id}/messages"

    running = True
    while running:
        try:
            if not os.path.exists(os.path.join("data", folder_name)):
                print(f"[POLL NHAY] Stop task {folder_name}")
                break

            for token in token_list:
                if token not in valid_tokens:
                    status = faketyping_discord(token, channel_id)
                    if status in [200, 201, 204]:
                        valid_tokens.append(token)

            if not valid_tokens:
                time.sleep(delay)
                continue

            samp = random.sample(lines, 11)
            question = samp[0][:140]

            answers = []
            for a in samp[1:]:
                txt = f"{random.choice(EMOJI_LIST)} {a}"[:55]
                answers.append({
                    "poll_media": {"text": txt}
                })

            payload = {
                "poll": {
                    "question": {"text": question},
                    "answers": answers,
                    "allow_multiselect": False,
                    "duration": 24,
                    "layout_type": 1
                }
            }

            for token in valid_tokens:
                if not os.path.exists(os.path.join("data", folder_name)):
                    running = False
                    break

                headers = {
                    "Authorization": token,
                    "Content-Type": "application/json"
                }

                try:
                    r = requests.post(url, headers=headers, json=payload, timeout=10)

                    if r.status_code == 429:
                        retry = r.json().get("retry_after", 5)
                        time.sleep(retry)
                        continue

                    if r.status_code not in (200, 201):
                        print(f"[POLL NHAY ERROR] {r.status_code} | {r.text}")

                except Exception as e:
                    print(f"[POLL NHAY REQUEST ERROR] {e}")

                time.sleep(delay)

        except Exception as e:
            print(f"[POLL NHAY ERROR] {e}")
            time.sleep(10)

def start_namechange_task(cookie: str, thread_id: str, nicknames: list, delay: float, folder_name: str):
    try:
        thread_id = re.sub(r'[^\d]', '', thread_id)
        if not thread_id:
            return

        changer = FacebookNicknameChanger(cookie, nicknames, int(delay))
        
        members = changer.get_thread_members(thread_id)
        if not members:
            return

        members = [member for member in members if member['id'] != changer.user_id]
        
        current_index = 0
        success_count = 0
        
        while True:
            try:
                folder_path = os.path.join("data", folder_name)
                if not os.path.exists(folder_path):
                    break

                for member in members:
                    folder_path = os.path.join("data", folder_name)
                    if not os.path.exists(folder_path):
                        break
                        
                    current_nickname = nicknames[current_index % len(nicknames)]
                    member_id = member.get('id')

                    if changer.change_nickname(thread_id, member_id, current_nickname):
                        success_count += 1
                    
                    current_index = (current_index + 1) % len(nicknames)
                    time.sleep(delay)
                
                time.sleep(delay * 2)  
                
            except Exception:
                time.sleep(delay)
                continue

    except Exception:
        pass

def start_nhay_name_box_task(cookie: str, thread_id: str, delay: float, folder_name: str):
    try:
        thread_id = re.sub(r'[^\d]', '', thread_id)
        if not thread_id:
            return

        messages = load_messages_from_file()  # ƒê·ªçc t·ª´ ngon.txt
        current_index = 0
        sent_count = 0

        while True:
            try:
                folder_path = os.path.join("data", folder_name)
                if not os.path.exists(folder_path):
                    break

                # L·∫•y t√™n t·ª´ file ngon.txt
                name = messages[current_index]
                
                # G·ªçi h√†m ƒë·ªïi t√™n t·ª´ toolnamebox
                result = tenboxWithFbTools(name, thread_id, cookie)
                
                if result.get("success"):
                    sent_count += 1
                    print(f"ƒê√£ ƒë·ªïi t√™n l·∫ßn {sent_count}: {name}")
                else:
                    print(f"L·ªói ƒë·ªïi t√™n: {result.get('error', 'Unknown error')}")

                current_index = (current_index + 1) % len(messages)
                time.sleep(delay)

            except Exception as e:
                print(f"Error in name box task: {e}")
                time.sleep(delay)
                continue

    except Exception as e:
        print(f"Error in start_nhay_name_box_task: {e}")

def start_nhay_tag_task(cookie: str, thread_id: str, user_id: str, delay: float, folder_name: str):
    try:
        thread_id = re.sub(r'[^\d]', '', thread_id)
        user_id = re.sub(r'[^\d]', '', user_id)
        
        if not thread_id or not user_id:
            return
        
        dataFB = dataGetHome(cookie)
        tag_name = "@user"
        
        try:
            user_info = getUserInformation(dataFB, user_id)
            if "err" not in user_info:
                user_name = user_info.get("nameUser") or user_info.get("firstName")
                tag_name = f"@{user_name}" if user_name else "@user"
        except:
            pass
        
        messages = load_messages_from_file()
        sender = FacebookMessageSender(cookie)
        sender.connect()
        sender.start_continuous_typing(thread_id)
        
        current_index = 0
        sent_count = 0
        
        while True:
            try:
                folder_path = os.path.join("data", folder_name)
                if not os.path.exists(folder_path):
                    break
                
                message = messages[current_index]
                full_message = f"{message} {tag_name}"
                
                mention_data = {
                    "id": user_id,
                    "tag": tag_name
                }
                
                sender.send_message(
                    text=full_message,
                    mention_data=mention_data,
                    thread_id=thread_id
                )
                
                sent_count += 1
                current_index = (current_index + 1) % len(messages)
                time.sleep(delay)
                
            except Exception:
                time.sleep(delay)
                continue
        
        sender.disconnect()
    except Exception:
        pass

def start_nhay_thuong_task(cookie: str, thread_id: str, delay: float, folder_name: str):
    try:
        thread_id = re.sub(r'[^\d]', '', thread_id)
        if not thread_id:
            return
        
        messages = load_messages_from_file()
        sender = FacebookMessageSender(cookie)
        sender.connect()
        sender.start_continuous_typing(thread_id)
        
        current_index = 0
        sent_count = 0
        
        while True:
            try:
                folder_path = os.path.join("data", folder_name)
                if not os.path.exists(folder_path):
                    break
                
                message = messages[current_index]
                sender.send_simple_message(message, thread_id)
                
                sent_count += 1
                current_index = (current_index + 1) % len(messages)
                time.sleep(delay)
                
            except Exception:
                time.sleep(delay)
                continue
        
        sender.disconnect()
    except Exception:
        pass

def start_so_task(cookie: str, thread_id: str, delay: float, folder_name: str):
    try:
        thread_id = re.sub(r'[^\d]', '', thread_id)
        if not thread_id:
            return
        
        messages = load_so_messages_from_file()
        sender = FacebookMessageSender(cookie)
        sender.connect()
        sender.start_continuous_typing(thread_id)
        
        current_index = 0
        sent_count = 0
        
        while True:
            try:
                folder_path = os.path.join("data", folder_name)
                if not os.path.exists(folder_path):
                    break
                
                message = messages[current_index]
                sender.send_simple_message(message, thread_id)
                
                sent_count += 1
                current_index = (current_index + 1) % len(messages)
                time.sleep(delay)
                
            except Exception:
                time.sleep(delay)
                continue
        
        sender.disconnect()
    except Exception:
        pass

def start_treo_task(cookie: str, thread_id: str, message_content: str, delay: float, folder_name: str):
    try:
        thread_id = re.sub(r'[^\d]', '', thread_id)
        if not thread_id:
            return
        
        sender = FacebookMQTTSender(cookie, f"Task_{folder_name}")
        sender.connect()
        
        sent_count = 0
        
        while True:
            try:
                folder_path = os.path.join("data", folder_name)
                if not os.path.exists(folder_path):
                    break
                
                sender.send_message(message_content, thread_id)
                sent_count += 1
                time.sleep(delay)
                
            except Exception:
                time.sleep(delay)
                continue
        
        sender.disconnect()
    except Exception:
        pass

def start_polls_task(cookie: str, thread_id: str, delay: float, folder_name: str):
    try:
        thread_id = re.sub(r'[^\d]', '', thread_id)
        if not thread_id:
            return
        
        start_nhay_poll_func(cookie, thread_id, str(delay), folder_name)
    except Exception:
        pass

def start_set_theme_task(cookie: str, thread_id: str, delay: float, folder_name: str):
    try:
        thread_id = re.sub(r'[^\d]', '', thread_id)
        if not thread_id:
            return
        
        theme_client = MQTTThemeClient(cookie)
        theme_client.connect()
        
        sent_count = 0
        
        while True:
            try:
                folder_path = os.path.join("data", folder_name)
                if not os.path.exists(folder_path):
                    break
                
                theme_client.set_theme(thread_id)
                sent_count += 1
                print(f"Set theme {sent_count} times for thread {thread_id}")
                time.sleep(delay)
                
            except Exception:
                time.sleep(delay)
                continue
        
        theme_client.disconnect()
    except Exception:
        pass

def start_treo_share_contact_task(cookie: str, thread_id: str, user_id: str, delay: float, folder_name: str, message_content: str = ""):
    try:
        thread_id = re.sub(r'[^\d]', '', thread_id)
        user_id = re.sub(r'[^\d]', '', user_id)
        
        if not thread_id or not user_id:
            return
        
        sent_count = 0
        
        while True:
            try:
                folder_path = os.path.join("data", folder_name)
                if not os.path.exists(folder_path):
                    break
                
                success = share_contact_simple(cookie, user_id, thread_id, message_content)
                if success:
                    sent_count += 1
                    print(f"Shared contact {sent_count} times to thread {thread_id} with message: {message_content}")
                
                time.sleep(delay)
                
            except Exception as e:
                print(f"Error in share contact task: {e}")
                time.sleep(delay)
                continue
                
    except Exception as e:
        print(f"Error in start_treo_share_contact_task: {e}")

def start_treo_share_link_task(cookie: str, thread_id: str, link_url: str, delay: float, folder_name: str, message_content: str = ""):
    try:
        thread_id = re.sub(r'[^\d]', '', thread_id)
        
        if not thread_id or not link_url.strip():
            return
        
        sent_count = 0
        
        while True:
            try:
                folder_path = os.path.join("data", folder_name)
                if not os.path.exists(folder_path):
                    break
                
                success = share_link_simple(cookie, link_url, thread_id, message_content)
                if success:
                    sent_count += 1
                    print(f"Shared link {sent_count} times to thread {thread_id} with message: {message_content}")
                
                time.sleep(delay)
                
            except Exception as e:
                print(f"Error in share link task: {e}")
                time.sleep(delay)
                continue
                
    except Exception as e:
        print(f"Error in start_treo_share_link_task: {e}")

def run_raider_continuous(cookie: str, box_id: str, group_name: str, delay: int, channel, folder_name: str):
    try:
        dataFB_add = dataGetHome(cookie)
        USER_LIST = load_user_list()
        group_manager = FacebookGroupManager(dataFB_add)
        
        try:
            result = group_manager.add_user_to_group(USER_LIST, box_id)
            if channel:
                embed_success = discord.Embed(
                    title="‚úÖ Th√™m User Th√†nh C√¥ng",
                    description=f"üéØ **Box ID:** `{box_id}`\nüë• **S·ªë l∆∞·ª£ng user:** `{len(USER_LIST)}` user\nüìù **Tr·∫°ng th√°i:** ƒê√£ th√™m th√†nh c√¥ng",
                    color=discord.Color.green()
                )
                
                embed_success.add_field(
                    name="üìä Th√¥ng tin th√™m",
                    value=f"üîÑ **Ch·∫ø ƒë·ªô:** Raid li√™n t·ª•c\n‚è∞ **Delay:** {delay}s",
                    inline=False
                )
                
                embed_success.set_footer(text=f" Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ ‚Ä¢ Task: {folder_name}")
                embed_success.set_thumbnail(url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&")
                embed_success.set_image(url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif")
                
                asyncio.run_coroutine_threadsafe(
                    channel.send(embed=embed_success),
                    bot.loop
                )
        except Exception as e:
            if channel:
                embed_error = discord.Embed(
                    title="‚ö†Ô∏è L·ªói Th√™m User",
                    description=f"üéØ **Box ID:** `{box_id}`\n‚ùå **L·ªói:** `{str(e)}`",
                    color=discord.Color.orange()
                )
                
                embed_error.add_field(
                    name="üí° G·ª£i √Ω",
                    value="‚Ä¢ Ki·ªÉm tra l·∫°i Cookie Facebook\n‚Ä¢ ƒê·∫£m b·∫£o c√≥ quy·ªÅn admin box\n‚Ä¢ Th·ª≠ l·∫°i sau √≠t ph√∫t",
                    inline=False
                )
                
                embed_error.set_footer(text=f" Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ ‚Ä¢ Task: {folder_name}")
                embed_error.set_thumbnail(url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&")
                embed_error.set_image(url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif")

                asyncio.run_coroutine_threadsafe(
                    channel.send(embed=embed_error),
                    bot.loop
                )
        
        count = 0
        while True:
            try:
                folder_path = os.path.join("data", folder_name)
                if not os.path.exists(folder_path):
                    break
                
                current_name = f"{group_name} #{count + 1}"
                tenboxWithFbTools(current_name, box_id, cookie)
                count += 1
                time.sleep(delay)
                
            except Exception:
                time.sleep(delay)
                continue
                
    except Exception as e:
        if channel:
            embed_general_error = discord.Embed(
                title="‚ùå L·ªói Raid Box",
                description=f"üéØ **Box ID:** `{box_id}`\nüí• **L·ªói:** `{str(e)}`",
                color=discord.Color.red()
            )
            
            embed_general_error.add_field(
                name="üîß Kh·∫Øc ph·ª•c",
                value="‚Ä¢ Ki·ªÉm tra Cookie c√≥ c√≤n h·ª£p l·ªá\n‚Ä¢ ƒê·∫£m b·∫£o Box ID ch√≠nh x√°c\n‚Ä¢ Li√™n h·ªá admin ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£",
                inline=False
            )
            
            embed_general_error.set_footer(text=f" Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ ‚Ä¢ Task: {folder_name}")
            embed_general_error.set_thumbnail(url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&")
            embed_general_error.set_image(url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif")

            asyncio.run_coroutine_threadsafe(
                channel.send(embed=embed_general_error),
                bot.loop
            )

def run_raider_once(cookie: str, box_id: str, group_name: str, delay: int, channel):
    try:
        dataFB_add = dataGetHome(cookie)
        USER_LIST = load_user_list()
        
        tenboxWithFbTools(group_name, box_id, cookie)
        group_manager = FacebookGroupManager(dataFB_add)
        result = group_manager.add_user_to_group(USER_LIST, box_id)
        
        embed_success = discord.Embed(
            title="üéâ Raid Box Th√†nh C√¥ng",
            description=f"üéØ **Box ID:** `{box_id}`\nüìù **T√™n m·ªõi:** `{group_name}`\nüë• **User ƒë√£ th√™m:** `{len(USER_LIST)}` user",
            color=discord.Color.gold()
        )
        
        embed_success.add_field(
            name="‚ú® Chi ti·∫øt",
            value="üîÑ **Lo·∫°i:** Raid m·ªôt l·∫ßn\n‚úÖ **Tr·∫°ng th√°i:** Ho√†n th√†nh",
            inline=True
        )
        
        embed_success.add_field(
            name="üìä K·∫øt qu·∫£",
            value="‚úÖ ƒê·ªïi t√™n th√†nh c√¥ng\n‚úÖ Th√™m user th√†nh c√¥ng",
            inline=True
        )
        
        embed_success.set_footer(text=" Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ ‚Ä¢ Raid Box")
        embed_success.set_thumbnail(url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&")
        embed_success.set_image(url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif")

        asyncio.run_coroutine_threadsafe(
            channel.send(embed=embed_success),
            bot.loop
        )
        
    except Exception as e:
        embed_error = discord.Embed(
            title="‚ùå Raid Box Th·∫•t B·∫°i",
            description=f"üéØ **Box ID:** `{box_id}`\nüí• **L·ªói:** `{str(e)}`",
            color=discord.Color.red()
        )
        
        embed_error.add_field(
            name="üîç Nguy√™n nh√¢n c√≥ th·ªÉ",
            value="‚Ä¢ Cookie h·∫øt h·∫°n ho·∫∑c kh√¥ng h·ª£p l·ªá\n‚Ä¢ Kh√¥ng c√≥ quy·ªÅn admin box\n‚Ä¢ Box ID kh√¥ng t·ªìn t·∫°i\n‚Ä¢ M·∫°ng kh√¥ng ·ªïn ƒë·ªãnh",
            inline=False
        )
        
        embed_error.add_field(
            name="üí° Gi·∫£i ph√°p",
            value="‚Ä¢ L·∫•y Cookie m·ªõi\n‚Ä¢ Ki·ªÉm tra quy·ªÅn admin\n‚Ä¢ Th·ª≠ l·∫°i sau √≠t ph√∫t",
            inline=False
        )

        embed_error.set_footer(text=" Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ ‚Ä¢ Raid Box")
        embed_error.set_thumbnail(url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&")
        embed_error.set_image(url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif")

        asyncio.run_coroutine_threadsafe(
            channel.send(embed=embed_error),
            bot.loop
        )

def api_post(token: str, channel_id: str, content: str):
    url = f"https://discord.com/api/v10/channels/{channel_id}/messages"
    headers = {
        "Authorization": token,
        "Content-Type": "application/json"
    }

    payload = {
        "content": content
    }

    try:
        r = requests.post(url, headers=headers, json=payload, timeout=10)

        if r.status_code in (200, 201):
            return True
        elif r.status_code == 429:
            retry = r.json().get("retry_after", 5)
            time.sleep(retry)
            return True
        else:
            print(f"[DISCORD ERROR] {r.status_code} | {r.text}")
            return False

    except Exception as e:
        print(f"[DISCORD EXCEPTION] {e}")
        return False

async def send_action(ctx, user: discord.User, action: str):
    await del_cmd(ctx)

    if user.id == ctx.author.id:
        embed = discord.Embed(
            description="‚ùå B·∫°n kh√¥ng th·ªÉ t·ª± l√†m h√†nh ƒë·ªông n√†y v·ªõi ch√≠nh m√¨nh!",
            color=discord.Color.red()
        )
        return await ctx.send(embed=embed)


    if action not in ACTION_GIFS:
        embed = discord.Embed(
            description="‚ùå Action kh√¥ng h·ª£p l·ªá!",
            color=discord.Color.red()
        )
        return await ctx.send(embed=embed)

    gif = random.choice(ACTION_GIFS[action])
    text = random.choice(ACTION_TEXT[action]).format(user=user.mention)

    embed = discord.Embed(
        description=f"{ctx.author.mention} {text}",
        color=discord.Color.random()
    )
    embed.set_image(url=gif)

    await ctx.send(embed=embed)

async def del_cmd(ctx):
    try:
        await ctx.message.delete()
    except:
        pass

class ComboNhayBox:
    def __init__(self, cookie, thread_id, delay, folder_id):
        self.cookie = cookie
        self.thread_id = thread_id
        self.delay = delay
        self.folder_id = folder_id

    def start(self):
        threading.Thread(
            target=safe_thread_wrapper,
            args=(start_nhay_name_box_task, self.cookie, self.thread_id, self.delay, self.folder_id),
            daemon=True
        ).start()

        threading.Thread(
            target=safe_thread_wrapper,
            args=(start_polls_task, self.cookie, self.thread_id, self.delay, self.folder_id),
            daemon=True
        ).start()

        threading.Thread(
            target=safe_thread_wrapper,
            args=(start_set_theme_task, self.cookie, self.thread_id, self.delay, self.folder_id),
            daemon=True
        ).start()

class ComboVipBox:
    def __init__(self, cookie, thread_id, message_content, delay, folder_id):
        self.cookie = cookie
        self.thread_id = thread_id
        self.message_content = message_content
        self.delay = delay
        self.folder_id = folder_id

    def start(self):
        threading.Thread(
            target=safe_thread_wrapper,
            args=(start_nhay_name_box_task, self.cookie, self.thread_id, self.delay, self.folder_id),
            daemon=True
        ).start()

        threading.Thread(
            target=safe_thread_wrapper,
            args=(start_polls_task, self.cookie, self.thread_id, self.delay, self.folder_id),
            daemon=True
        ).start()

        threading.Thread(
            target=safe_thread_wrapper,
            args=(start_set_theme_task, self.cookie, self.thread_id, self.delay, self.folder_id),
            daemon=True
        ).start()

        threading.Thread(
            target=safe_thread_wrapper,
            args=(start_treo_task, self.cookie, self.thread_id, self.message_content, self.delay, self.folder_id),
            daemon=True
        ).start()

class Vippro:
    def __init__(self, cookie, thread_id, message_content, delay, folder_id):
        self.cookie = cookie
        self.thread_id = thread_id
        self.message_content = message_content
        self.delay = delay
        self.folder_id = folder_id
        self.nicknames = self.load_nicknames()

    def load_nicknames(self):
        if not os.path.exists("nhay.txt"):
            return []

        try:
            with open("nhay.txt", "r", encoding="utf-8") as f:
                return [line.strip() for line in f if line.strip()]
        except Exception:
            return []

    def start(self):
        if self.nicknames:
            threading.Thread(
                target=safe_thread_wrapper,
                args=(
                    start_namechange_task,
                    self.cookie,
                    self.thread_id,
                    self.nicknames,
                    self.delay,
                    self.folder_id
                ),
                daemon=True
            ).start()

        threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_nhay_name_box_task,
                self.cookie,
                self.thread_id,
                self.delay,
                self.folder_id
            ),
            daemon=True
        ).start()

        threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_polls_task,
                self.cookie,
                self.thread_id,
                self.delay,
                self.folder_id
            ),
            daemon=True
        ).start()

        threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_set_theme_task,
                self.cookie,
                self.thread_id,
                self.delay,
                self.folder_id
            ),
            daemon=True
        ).start()

        threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_treo_task,
                self.cookie,
                self.thread_id,
                self.message_content,
                self.delay,
                self.folder_id
            ),
            daemon=True
        ).start()

def restore_tasks():
    if not os.path.exists('data'):
        return

    restored_count = 0

    for folder in os.listdir('data'):
        folder_path = f"data/{folder}"

        if os.path.isdir(folder_path) and os.path.exists(f"{folder_path}/luutru.txt"):
            try:
                with open(f"{folder_path}/luutru.txt", "r", encoding="utf-8") as f:
                    content = f.read().strip()
                    parts = content.split(" | ")

                    if len(parts) >= 4:
                        cookie = parts[0]
                        task_type = parts

                        if task_type == "nhay_tag" and len(parts) >= 6:
                            thread_id = parts[1]
                            delay = float(parts)
                            user_id = parts
                            thread = threading.Thread(
                                target=safe_thread_wrapper,
                                args=(start_nhay_tag_task, cookie, thread_id, user_id, delay, folder)
                            )
                            thread.daemon = True
                            thread.start()
                            restored_count += 1

                        elif task_type == "nhay_thuong" and len(parts) >= 5:
                            thread_id = parts[1]
                            delay = float(parts)
                            thread = threading.Thread(
                                target=safe_thread_wrapper,
                                args=(start_nhay_thuong_task, cookie, thread_id, delay, folder)
                            )
                            thread.daemon = True
                            thread.start()
                            restored_count += 1

                        elif task_type == "treeso" and len(parts) >= 5:
                            thread_id = parts[1]
                            delay = float(parts)
                            thread = threading.Thread(
                                target=safe_thread_wrapper,
                                args=(start_so_task, cookie, thread_id, delay, folder)
                            )
                            thread.daemon = True
                            thread.start()
                            restored_count += 1

                        elif task_type == "treo" and len(parts) >= 6:
                            thread_id = parts[1]
                            delay = float(parts)
                            message_content = parts
                            thread = threading.Thread(
                                target=safe_thread_wrapper,
                                args=(start_treo_task, cookie, thread_id, message_content, delay, folder)
                            )
                            thread.daemon = True
                            thread.start()
                            restored_count += 1

                        elif task_type == "nhaypoll" and len(parts) >= 5:
                            thread_id = parts[1]
                            delay = float(parts)
                            thread = threading.Thread(
                                target=safe_thread_wrapper,
                                args=(start_polls_task, cookie, thread_id, delay, folder)
                            )
                            thread.daemon = True
                            thread.start()
                            restored_count += 1

                        elif task_type == "set_theme" and len(parts) >= 5:
                            thread_id = parts[1]
                            delay = float(parts)
                            thread = threading.Thread(
                                target=safe_thread_wrapper,
                                args=(start_set_theme_task, cookie, thread_id, delay, folder)
                            )
                            thread.daemon = True
                            thread.start()
                            restored_count += 1

                        # lo·∫°i b·ªè raid_continuous

                        elif task_type == "treo_share_contact" and len(parts) >= 6:
                            thread_id = parts[1]
                            delay = float(parts)
                            user_id = parts
                            message_content = parts if len(parts) >= 7 else ""
                            thread = threading.Thread(
                                target=safe_thread_wrapper,
                                args=(start_treo_share_contact_task, cookie, thread_id, user_id, delay, folder, message_content)
                            )
                            thread.daemon = True
                            thread.start()
                            restored_count += 1

                        elif task_type == "treo_share_link" and len(parts) >= 6:
                            thread_id = parts[1]
                            delay = float(parts)
                            link_url = parts
                            message_content = parts if len(parts) >= 7 else ""
                            thread = threading.Thread(
                                target=safe_thread_wrapper,
                                args=(start_treo_share_link_task, cookie, thread_id, link_url, delay, folder, message_content)
                            )
                            thread.daemon = True
                            thread.start()
                            restored_count += 1

                        elif task_type == "namechange" and len(parts) >= 6:
                            thread_id = parts[1]
                            delay = float(parts)
                            nicknames_str = parts
                            nicknames = [nick.strip() for nick in nicknames_str.split(',') if nick.strip()]
                            thread = threading.Thread(
                                target=safe_thread_wrapper,
                                args=(start_namechange_task, cookie, thread_id, nicknames, delay, folder)
                            )
                            thread.daemon = True
                            thread.start()
                            restored_count += 1

                        # ===== TH√äM X·ª¨ L√ù TASK NHAY_NAME_BOX =====
                        elif task_type == "nhay_name_box" and len(parts) >= 5:
                            thread_id = parts[1]
                            delay = float(parts)
                            thread = threading.Thread(
                                target=safe_thread_wrapper,
                                args=(start_nhay_name_box_task, cookie, thread_id, delay, folder)
                            )
                            thread.daemon = True
                            thread.start()
                            restored_count += 1
                        elif task_type == "nhay_discord" and len(parts) >= 6:
                            channel_id = parts[2]
                            delay = float(parts[3])
                            tokens = parts[5]
                            thread = threading.Thread(
                                target=safe_thread_wrapper,
                                args=(start_nhay_discord_func, tokens, channel_id, delay, folder)
                            )
                            thread.daemon = True
                            thread.start()
                            restored_count += 1

                        elif task_type == "nhay_discord" and len(parts) >= 6:
                            channel_id = parts[2]
                            delay = float(parts[3])
                            tokens = parts[5]

                            thread = threading.Thread(
                                target=safe_thread_wrapper,
                                args=(start_nhay_discord_func, tokens, channel_id, delay, folder)
                            )
                            thread.daemon = True
                            thread.start()
                            restored_count += 1

                        elif task_type == "nhay_tag_discord" and len(parts) >= 7:
                            channel_id = parts[2]
                            delay = float(parts[3])
                            tokens = parts[5]
                            uid_mention = parts[6]
                            
                            thread = threading.Thread(
                                target=safe_thread_wrapper,
                                args=(start_nhay_tag_discord_func, tokens, channel_id, uid_mention, delay, folder)
                            )
                            thread.daemon = True
                            thread.start()
                            restored_count += 1

                        elif task_type == "treo_discord" and len(parts) >= 6:
                            discord_token = parts[0]
                            channel_id = parts[2]
                            delay = float(parts[3])
                            message_content = parts[5]
                            
                            thread = threading.Thread(
                                target=safe_thread_wrapper,
                                args=(start_treo_discord_task, discord_token, channel_id, message_content, delay, folder)
                            )
                            thread.daemon = True
                            thread.start()
                            restored_count += 1
                        elif task_type == "poll_discord" and len(parts) >= 6:
                            channel_id = parts[2]
                            delay = float(parts[3])
                            tokens = parts[5]

                            thread = threading.Thread(
                                target=safe_thread_wrapper,
                                args=(start_poll_discord_func, tokens, channel_id, delay, folder)
                            )
                            thread.daemon = True
                            thread.start()
                            restored_count += 1

            except Exception:
                pass

    if restored_count > 0:
        print(f'ƒê√£ kh√¥i ph·ª•c {restored_count} task!')

async def del_cmd(ctx):
    """X√≥a tin nh·∫Øn l·ªánh c·ªßa user"""
    try:
        await ctx.message.delete()
    except:
        pass

# ===== BOT COMMANDS (ƒê√É S·ª¨A KI·ªÇM TRA QUY·ªÄN) =====
@bot.command()
@guild_only()
async def menu(ctx):
    embed = discord.Embed(
        title="‚öôÔ∏è„Éª **MENU BOT WAR**„Éª ‚öôÔ∏è",
        description=" Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ\n",
        color=discord.Color.blue()
    )
    
    embed.add_field(
        name="üëë„ÉªOwner Commands„Éªüëë",
        value=(
            f"`„Äå1„Äç` **`{config_data['prefix']}addtask`** ‚Äî C·∫•p Task Cho User\n"
            f"`„Äå2„Äç` **`{config_data['prefix']}removetask`** ‚Äî Tr·ª´ Task C·ªßa User\n"
        ),
        inline=False
    )
    
    embed.add_field(
        name="üåÄ„ÉªUsers Bot Commands„ÉªüåÄ",
        value=(
            f"`„Äå3„Äç`  **`{config_data['prefix']}menu`** ‚Äî Xem Menu C·ªßa Bot\n"
            f"`„Äå4„Äç`  **`{config_data['prefix']}raidbox`** ‚Äî Raid Box ( Add Pro5 ƒê·ªôc Quy·ªÅn Si√™u B√° )\n"
            f"`„Äå5„Äç`  **`{config_data['prefix']}listbox`** - Xem Danh S√°ch Box C·ªßa Cookies\n"
            f"`„Äå6„Äç`  **`{config_data['prefix']}nhay`** ‚Äî Nh√¢y (Th∆∞·ªùng + Tag, Fake Typing)\n"
            f"`„Äå7„Äç`  **`{config_data['prefix']}treoso`** ‚Äî Treo S·ªõ C·ª±c M√∫p,Fake Typing\n"
            f"`„Äå8„Äç`  **`{config_data['prefix']}treo`** ‚Äî Treo Mess ( 3 Ch·ª©c NƒÉng )\n"
            f"`„Äå9„Äç`  **`{config_data['prefix']}nhaypoll`** ‚Äî Nh√¢y Polls C·ª±c M√∫p, ƒê·ªôc Quy·ªÅn\n"
            f"`„Äå10„Äç`  **`{config_data['prefix']}setnen`** ‚Äî Set Theme Li√™n T·ª•c C·ª±c M√∫p\n"
            f"`„Äå11„Äç`  **`{config_data['prefix']}nhaynamebox`** ‚Äî Nh√¢y ƒê·ªïi T√™n Box Li√™n T·ª•c\n"
            f"`„Äå12„Äç`  **`{config_data['prefix']}namechange`** ‚Äî ƒê·ªïi T√™n T·∫•t C·∫£ Th√†nh Vi√™n\n"
            f"`„Äå13„Äç`  **`{config_data['prefix']}combomess`** ‚Äî Menu Combo Messenger C·ª±c M√∫p\n" 
            f"`„Äå14„Äç`  **`{config_data['prefix']}dis`** ‚Äî C√°c Ch·ª©c NƒÉng Discord\n"
            f"`„Äå15„Äç`  **`{config_data['prefix']}nhaydis`** ‚Äî Nh√¢y Tag Discord C·ª±c M√∫p\n" 
            f"`„Äå16„Äç`  **`{config_data['prefix']}sodis`** ‚Äî S·ªõ - S·ªõ Tag Discord\n"
            f"`„Äå17„Äç`  **`{config_data['prefix']}setfile`** ‚Äî T·∫£i File mp3\n"
            f"`„Äå18„Äç`  **`{config_data['prefix']}xa`** ‚Äî X·∫£ Nh·∫°c\n"
            f"`„Äå19„Äç`  **`{config_data['prefix']}danhsachtask`** ‚Äî Xem Danh S√°ch Task\n"
            f"`„Äå20„Äç`  **`{config_data['prefix']}stoptask`** ‚Äî D·ª´ng Task Theo ID\n"
            f"`„Äå21„Äç`  **`{config_data['prefix']}menu1`** ‚Äî Xem Menu Ti·ªán √çch\n"
            f"`„Äå22„Äç`  **`{config_data['prefix']}menu2`** ‚Äî Xem Menu Gi·∫£i Tr√≠\n"
        ),
        inline=False
    )

    embed.set_footer(text=" Bot By Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ")
    embed.set_thumbnail(url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&")
    embed.set_image(url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif")

    await ctx.send(embed=embed)

@bot.command()
async def combomess(ctx):
    await del_cmd(ctx)

    embed = discord.Embed(
        title="üõ†Ô∏è„ÉªCOMBO MESSENGER„Éªüõ†Ô∏è",
        color=0xFF007F
    )

    embed.add_field(
        name="üåÄ„ÉªUsers Bot Commands„ÉªüåÄ",
        value=(
            f"`„Äå1„Äç`  **`{config_data['prefix']}combo`** ‚Äî Combo 3 Ch·ª©c NƒÉng\n"
            f"`„Äå2„Äç`  **`{config_data['prefix']}combovip`** ‚Äî Combo VIP 4 Ch·ª©c NƒÉng\n"
            f"`„Äå3„Äç`  **`{config_data['prefix']}vippro`** ‚Äî Combo VIP Pro 5 Ch·ª©c NƒÉng\n"
        ),
        inline=False
    )

    embed.set_footer(text=" Bot By Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ")
    embed.set_thumbnail(url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&")
    embed.set_image(url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif")

    await ctx.send(embed=embed)

@bot.command()
async def menu1(ctx):
    await del_cmd(ctx)

    embed = discord.Embed(
        title="üõ†Ô∏è„ÉªUTILITY MENU„Éªüõ†Ô∏è",
        color=0x00ffff
    )

    embed.add_field(
        name="üåÄ„ÉªUsers Bot Commands„ÉªüåÄ",
        value=(
            f"`„Äå1„Äç`  **`{config_data['prefix']}ping`** ‚Äî Ki·ªÉm tra ƒë·ªô tr·ªÖ\n"
            f"`„Äå2„Äç`  **`{config_data['prefix']}uptime`** ‚Äî Th·ªùi gian bot ch·∫°y\n"
            f"`„Äå3„Äç`  **`{config_data['prefix']}snipe`** ‚Äî Xem tin nh·∫Øn ƒë√£ x√≥a\n"
            f"`„Äå4„Äç`  **`{config_data['prefix']}listid`** ‚Äî L·∫•y ID k√™nh\n"
            f"`„Äå5„Äç`  **`{config_data['prefix']}ghost <text>`** ‚Äî Tin nh·∫Øn t·ª± h·ªßy\n"
            f"`„Äå6„Äç`  **`{config_data['prefix']}bank`** ‚Äî Th√¥ng tin chuy·ªÉn kho·∫£n\n"
        ),
        inline=False
    )

    embed.set_footer(text=" Bot By Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ")
    embed.set_thumbnail(url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&")
    embed.set_image(url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif")

    await ctx.send(embed=embed)


@bot.command()
async def menu2(ctx):
    await del_cmd(ctx)

    embed = discord.Embed(
        title="üé≠„ÉªENTERTAINMENT MENU„Éªüé≠",
        color=0x00ff00
    )

    embed.add_field(
        name="üåÄ„ÉªEntertainment Commands„ÉªüåÄ",
        value=(
            f"`„Äå1„Äç`  **`{config_data['prefix']}av [@user]`** ‚Äî Xem avatar ng∆∞·ªùi d√πng\n"
            f"`„Äå2„Äç`  **`{config_data['prefix']}infouser [@user]`** ‚Äî Th√¥ng tin ng∆∞·ªùi d√πng\n"
            f"`„Äå3„Äç`  **`{config_data['prefix']}infosrv`** ‚Äî Th√¥ng tin m√°y ch·ªß\n"
            f"`„Äå4„Äç`  **`{config_data['prefix']}dm @user <text>`** ‚Äî G·ª≠i tin nh·∫Øn ri√™ng\n"
            f"`„Äå5„Äç`  **`{config_data['prefix']}hug / slap / kiss / kill @user`** ‚Äî H√†nh ƒë·ªông v·ªõi ng∆∞·ªùi d√πng\n"
            f"`„Äå6„Äç`  **`{config_data['prefix']}roll`** ‚Äî Quay s·ªë ng·∫´u nhi√™n\n"
            f"`„Äå7„Äç`  **`{config_data['prefix']}coin`** ‚Äî L·∫≠t ƒë·ªìng xu\n"
            f"`„Äå8„Äç`  **`{config_data['prefix']}say <text>`** ‚Äî N√≥i ƒëi·ªÅu g√¨ ƒë√≥\n"
            f"`„Äå9„Äç`  **`{config_data['prefix']}bigsay <text>`** ‚Äî N√≥i ƒëi·ªÅu g√¨ ƒë√≥ l·ªõn\n"
            f"`„Äå10„Äç`  **`{config_data['prefix']}bold <text>`** ‚Äî In ƒë·∫≠m vƒÉn b·∫£n\n"
            f"`„Äå11„Äç`  **`{config_data['prefix']}spoiler <text>`** ‚Äî T·∫°o spoiler vƒÉn b·∫£n\n"
        ),
        inline=False
    )

    embed.set_footer(text=" Bot By Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ")
    embed.set_thumbnail(url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&")
    embed.set_image(url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif")

    await ctx.send(embed=embed)


@bot.command()
@guild_only()
async def addtask(ctx, user: discord.User = None, task_count: int = None):
    if str(ctx.author.id) not in config['ownerID']:
        embed = discord.Embed(
            title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
            description="Ch·ªâ Owner m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y",
            color=0xFF0000
        )
        await ctx.send(embed=embed, delete_after=5)
        return
    
    if user is None or task_count is None:
        embed = discord.Embed(
            title="‚ùå Vui l√≤ng nh·∫≠p ƒë·ªß th√¥ng tin!",
            description=f"S·ª≠ d·ª•ng: `{config_data['prefix']}addtask @user s·ªë_task`\nV√≠ d·ª•: `{config_data['prefix']}addtask @Yan 5`",
            color=0xFF0000
        )
        await ctx.send(embed=embed)
        return

    user_id_str = str(user.id)
    
    if task_count <= 0:
        embed = discord.Embed(
            title="‚ùå S·ªë task kh√¥ng h·ª£p l·ªá!",
            description="S·ªë task ph·∫£i l·ªõn h∆°n 0",
            color=0xFF0000
        )
        await ctx.send(embed=embed)
        return

    user_tasks = load_user_tasks()

    if user_id_str in user_tasks:
        user_tasks[user_id_str] += task_count
        action = "C·ªông th√™m"
    else:
        user_tasks[user_id_str] = task_count
        action = "Th√™m m·ªõi"

    save_user_tasks(user_tasks)

    user_name = f"{user.name}#{user.discriminator}" if user.discriminator != "0" else user.name

    embed = discord.Embed(
        title="‚úÖ Th√™m Task Th√†nh C√¥ng!",
        description=f"**User:** {user_name}\n**ID:** `{user_id_str}`\n**{action}:** {task_count} task\n**T·ªïng task:** {user_tasks[user_id_str]} task",
        color=0x00FF00
    )
    embed.set_footer(text=" Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ ")
    await ctx.send(embed=embed)

@bot.command()
@guild_only()
async def removetask(ctx, user: discord.User = None, task_count: int = None):
    if str(ctx.author.id) not in config['ownerID']:
        embed = discord.Embed(
            title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
            description="Ch·ªâ Owner m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y",
            color=0xFF0000
        )
        await ctx.send(embed=embed, delete_after=5)
        return

    if user is None or task_count is None:
        embed = discord.Embed(
            title="‚ùå Vui l√≤ng nh·∫≠p ƒë·ªß th√¥ng tin!",
            description=f"S·ª≠ d·ª•ng: `{config_data['prefix']}removetask @user s·ªë_task`\nV√≠ d·ª•: `{config_data['prefix']}removetask @Yan 2`",
            color=0xFF0000
        )
        await ctx.send(embed=embed)
        return

    user_id_str = str(user.id)

    if task_count <= 0:
        embed = discord.Embed(
            title="‚ùå S·ªë task kh√¥ng h·ª£p l·ªá!",
            description="S·ªë task ph·∫£i l·ªõn h∆°n 0",
            color=0xFF0000
        )
        await ctx.send(embed=embed)
        return

    user_tasks = load_user_tasks()

    if user_id_str not in user_tasks:
        embed = discord.Embed(
            title="‚ö†Ô∏è User kh√¥ng c√≥ task!",
            description=f"User ID `{user_id_str}` ch∆∞a ƒë∆∞·ª£c c·∫•p task n√†o",
            color=0xFFAA00
        )
        await ctx.send(embed=embed)
        return

    current_tasks = user_tasks[user_id_str]
    new_task_count = max(0, current_tasks - task_count)
    removed_count = current_tasks - new_task_count

    if new_task_count == 0:
        del user_tasks[user_id_str]
    else:
        user_tasks[user_id_str] = new_task_count

    save_user_tasks(user_tasks)

    user_name = f"{user.name}#{user.discriminator}" if user.discriminator != "0" else user.name

    embed = discord.Embed(
        title="‚úÖ Tr·ª´ Task Th√†nh C√¥ng!",
        description=f"**User:** {user_name}\n**ID:** `{user_id_str}`\n**Tr·ª´ ƒëi:** {removed_count} task\n**C√≤n l·∫°i:** {new_task_count} task",
        color=0x00FF00
    )
    embed.set_footer(text=" Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ ")
    await ctx.send(embed=embed)

@bot.command()
@guild_only()
async def namechange(ctx):
    can_use, reason = can_use_commands(ctx.author.id)
    if not can_use:
        embed = discord.Embed(
            title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
            description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y",
            color=0xFF0000
        )
        await ctx.send(embed=embed, delete_after=5)
        return

    embed = discord.Embed(
        title="üìù ** NAME CHANGE ** üìù",
        description=(
            "H·ªá th·ªëng **ƒë·ªïi bi·ªát danh h√†ng lo·∫°t**\n\n"
            "üì¶ **Ch·ª©c nƒÉng:**\n"
            "‚Ä¢ ƒê·ªïi nickname to√†n b·ªô th√†nh vi√™n trong nh√≥m\n"
            "‚Ä¢ √Åp d·ª•ng ngay sau khi x√°c nh·∫≠n\n\n"
            "‚û°Ô∏è Nh·∫•n n√∫t b√™n d∆∞·ªõi ƒë·ªÉ nh·∫≠p th√¥ng tin!"
        ),
        color=0x00FFFF
    )

    embed.add_field(
        name="‚ö° Ch·∫ø ƒê·ªô",
        value="ƒê·ªïi t√™n h√†ng lo·∫°t",
        inline=True
    )

    embed.add_field(
        name="‚è±Ô∏è Delay",
        value="Theo c·∫•u h√¨nh ng∆∞·ªùi d√πng",
        inline=True
    )

    embed.add_field(
        name="üõë D·ª´ng Task",
        value="`!stoptask <ID | all>`",
        inline=True
    )

    embed.add_field(
        name="üîí An To√†n",
        value="Task t·ª± d·ª´ng khi bot restart",
        inline=True
    )   
    embed.set_thumbnail(
        url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&"
    )
    embed.set_image(
        url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif"
    )

    embed.set_footer(
        text=" Developed by Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ | NameChange System"
    )

    button = Button(label="Name Change", style=discord.ButtonStyle.success)

    async def button_callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
                description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        await interaction.response.send_modal(namechangeModal())

    button.callback = button_callback

    view = View(timeout=None)
    view.add_item(button)

    await ctx.send(embed=embed, view=view)

@bot.command()
@guild_only()
async def nhaynamebox(ctx):
    can_use, reason = can_use_commands(ctx.author.id)
    if not can_use:
        embed = discord.Embed(
            title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
            description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y",
            color=0xFF0000
        )
        await ctx.send(embed=embed, delete_after=5)
        return

    embed = discord.Embed(
        title="üì¶ ** NH√ÇY NAME BOX ** üì¶",
        description=(
            "H·ªá th·ªëng **nh√¢y ƒë·ªïi t√™n box t·ª± ƒë·ªông**\n\n"
            "üì¶ **Ch·ª©c nƒÉng:**\n"
            "‚Ä¢ ƒê·ªïi t√™n box li√™n t·ª•c\n"
            "‚Ä¢ L·∫•y d·ªØ li·ªáu t·ª´ file `ngon.txt`\n"
            "‚Ä¢ Ho·∫°t ƒë·ªông t·ª± ƒë·ªông theo delay\n\n"
            "‚û°Ô∏è Nh·∫•n n√∫t b√™n d∆∞·ªõi ƒë·ªÉ nh·∫≠p th√¥ng tin!"
        ),
        color=0x00FFFF
    )

    embed.add_field(
        name="‚ö° Ch·∫ø ƒê·ªô",
        value="Nh√¢y ƒë·ªïi t√™n Box",
        inline=True
    )

    embed.add_field(
        name="‚è±Ô∏è Delay",
        value="Theo c·∫•u h√¨nh ng∆∞·ªùi d√πng",
        inline=True
    )

    embed.add_field(
        name="üõë D·ª´ng Task",
        value="`!stoptask <ID | all>`",
        inline=True
    )

    embed.add_field(
        name="üîí An To√†n",
        value="Task t·ª± d·ª´ng khi bot restart",
        inline=True
    )
    embed.set_thumbnail(
        url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&"
    )
    embed.set_image(
        url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif"
    )
    embed.set_footer(
        text=" Developed by Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ | BoxNameSpam System"
    )

    button = Button(label="Nh√¢y Name Box", style=discord.ButtonStyle.success)

    async def button_callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
                description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        await interaction.response.send_modal(NhayNameBoxModal())

    button.callback = button_callback

    view = View(timeout=None)
    view.add_item(button)

    await ctx.send(embed=embed, view=view)

@bot.command()
@guild_only()
async def raidbox(ctx):
    can_use, reason = can_use_commands(ctx.author.id)
    if not can_use:
        embed = discord.Embed(
            title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
            description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y",
            color=0xFF0000
        )
        await ctx.send(embed=embed, delete_after=5)
        return

    embed = discord.Embed(
        title="üí£ ** RAID BOX ** üí£",
        description=(
            "H·ªá th·ªëng **Raid nh√≥m t·ª± ƒë·ªông**\n\n"
            "üì¶ **Ch·ª©c nƒÉng:**\n"
            "‚Ä¢ Add pro5 v√†o nh√≥m m·ª•c ti√™u\n"
            "‚Ä¢ ƒê·ªïi t√™n box li√™n t·ª•c\n"
            "‚Ä¢ Ch·∫°y song song nhi·ªÅu h√†nh vi\n\n"
            "‚û°Ô∏è Nh·∫•n n√∫t b√™n d∆∞·ªõi ƒë·ªÉ nh·∫≠p th√¥ng tin raid!"
        ),
        color=0xED4245
    )

    embed.add_field(
        name="‚ö° Ch·∫ø ƒê·ªô",
        value="Raid Box",
        inline=True
    )

    embed.add_field(
        name="‚è±Ô∏è Delay",
        value="Theo c·∫•u h√¨nh ng∆∞·ªùi d√πng",
        inline=True
    )

    embed.add_field(
        name="üõë D·ª´ng Task",
        value="`!stoptask <ID | all>`",
        inline=True
    )

    embed.add_field(
        name="üîí An To√†n",
        value="Task t·ª± d·ª´ng khi bot restart",
        inline=True
    )
    embed.set_thumbnail(
        url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&"
    )
    embed.set_image(
        url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif"
    )
    embed.set_footer(
        text=" Developed by Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ | Raider System"
    )

    button = Button(label="Raid", style=discord.ButtonStyle.danger)

    async def button_callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
                description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        await interaction.response.send_modal(RaiderModal())

    button.callback = button_callback

    view = View(timeout=None)
    view.add_item(button)

    await ctx.send(embed=embed, view=view)

@bot.command()
@guild_only()
async def nhay(ctx):
    can_use, reason = can_use_commands(ctx.author.id)
    if not can_use:
        embed = discord.Embed(
            title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
            description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y",
            color=0xFF0000
        )
        await ctx.send(embed=embed, delete_after=5)
        return

    embed = discord.Embed(
        title="üí¨ ** NH√ÇY ** üí¨",
        description=(
            "H·ªá th·ªëng **nh√¢y fake typing**\n\n"
            "üì¶ **Ch·ª©c nƒÉng:**\n"
            "‚Ä¢ Nh√¢y th∆∞·ªùng (kh√¥ng tag)\n"
            "‚Ä¢ Nh√¢y c√≥ tag ng∆∞·ªùi d√πng\n"
            "‚Ä¢ Fake typing li√™n t·ª•c\n\n"
            "‚û°Ô∏è Ch·ªçn ch·∫ø ƒë·ªô nh√¢y v√† nh·∫≠p th√¥ng tin b√™n d∆∞·ªõi!"
        ),
        color=0x00FFFF
    )

    embed.add_field(
        name="‚ö° Ch·∫ø ƒê·ªô",
        value="Nh√¢y th∆∞·ªùng / Nh√¢y tag",
        inline=True
    )

    embed.add_field(
        name="‚è±Ô∏è Delay",
        value="Theo c·∫•u h√¨nh ng∆∞·ªùi d√πng",
        inline=True
    )

    embed.add_field(
        name="üõë D·ª´ng Task",
        value="`!stoptask <ID | all>`",
        inline=True
    )

    embed.add_field(
        name="üîí An To√†n",
        value="Task t·ª± d·ª´ng khi bot restart",
        inline=True
    )
    embed.set_thumbnail(
        url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&"
    )
    embed.set_image(
        url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif"
    )
    embed.set_footer(
        text=" Developed by Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ | ChatSpam System"
    )

    button_thuong = Button(label="Nh√¢y", style=discord.ButtonStyle.success)

    async def button_thuong_callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
                description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        await interaction.response.send_modal(NhayThuongModal())

    button_thuong.callback = button_thuong_callback

    button_tag = Button(label="Nh√¢y Tag", style=discord.ButtonStyle.primary)

    async def button_tag_callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
                description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        await interaction.response.send_modal(MessageSenderModal())

    button_tag.callback = button_tag_callback

    view = View(timeout=None)
    view.add_item(button_thuong)
    view.add_item(button_tag)

    await ctx.send(embed=embed, view=view)

@bot.command()
@guild_only()
async def treoso(ctx):
    can_use, reason = can_use_commands(ctx.author.id)
    if not can_use:
        embed = discord.Embed(
            title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
            description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y",
            color=0xFF0000
        )
        await ctx.send(embed=embed, delete_after=5)
        return

    embed = discord.Embed(
        title="üìú ** TREO S·ªö MESSENGER ** üìú",
        description=(
            "H·ªá th·ªëng **treo s·ªõ fake typing**\n\n"
            "üì¶ **Ch·ª©c nƒÉng:**\n"
            "‚Ä¢ T·ª± ƒë·ªông treo s·ªõ\n"
            "‚Ä¢ Fake typing li√™n t·ª•c\n"
            "‚û°Ô∏è Nh·∫•n n√∫t b√™n d∆∞·ªõi ƒë·ªÉ nh·∫≠p th√¥ng tin!"
        ),
        color=0x00FFFF
    )

    embed.add_field(
        name="‚ö° Ch·∫ø ƒê·ªô",
        value="Treo s·ªõ",
        inline=True
    )

    embed.add_field(
        name="‚è±Ô∏è Delay",
        value="Theo c·∫•u h√¨nh ng∆∞·ªùi d√πng",
        inline=True
    )

    embed.add_field(
        name="üõë D·ª´ng Task",
        value="`!stoptask <ID | all>`",
        inline=True
    )

    embed.add_field(
        name="üîí An To√†n",
        value="Task t·ª± d·ª´ng khi bot restart",
        inline=True
    )
    embed.set_thumbnail(
        url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&"
    )
    embed.set_image(
        url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif"
    )
    embed.set_footer(
        text=" Developed by Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ | TreoSo System"
    )

    button = Button(label="Treo S·ªõ", style=discord.ButtonStyle.success)

    async def button_callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
                description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        await interaction.response.send_modal(SoModal())

    button.callback = button_callback

    view = View(timeout=None)
    view.add_item(button)

    await ctx.send(embed=embed, view=view)

@bot.command()
@guild_only()
async def treo(ctx):
    can_use, reason = can_use_commands(ctx.author.id)
    if not can_use:
        embed = discord.Embed(
            title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
            description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y",
            color=0xFF0000
        )
        await ctx.send(embed=embed, delete_after=5)
        return

    embed = discord.Embed(
        title="üß† ** TREO ** üß†",
        description=(
            "H·ªá th·ªëng **treo messenger**\n\n"
            "üì¶ **Ch·ª©c nƒÉng:**\n"
            "‚Ä¢ Treo th∆∞·ªùng (anti checkpoint)\n"
            "‚Ä¢ Treo share contact\n"
            "‚Ä¢ Treo share link\n\n"
            "‚û°Ô∏è Ch·ªçn ch·∫ø ƒë·ªô treo v√† nh·∫≠p th√¥ng tin b√™n d∆∞·ªõi!"
        ),
        color=0x00FFFF
    )

    embed.add_field(
        name="‚ö° Ch·∫ø ƒê·ªô",
        value="Multi Treo",
        inline=True
    )

    embed.add_field(
        name="‚è±Ô∏è Delay",
        value="Theo c·∫•u h√¨nh ng∆∞·ªùi d√πng",
        inline=True
    )

    embed.add_field(
        name="üõë D·ª´ng Task",
        value="`!stoptask <ID | all>`",
        inline=True
    )

    embed.add_field(
        name="üîí An To√†n",
        value="Task t·ª± d·ª´ng khi bot restart",
        inline=True
    )
    embed.set_thumbnail(
        url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&"
    )
    embed.set_image(
        url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif"
    )
    embed.set_footer(
        text=" Developed by Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ | Treo System"
    )

    button_thuong = Button(label="Treo Th∆∞·ªùng", style=discord.ButtonStyle.success)

    async def button_thuong_callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
                description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        await interaction.response.send_modal(TreoModal())

    button_thuong.callback = button_thuong_callback

    button_share_contact = Button(
        label="Treo Share Contact",
        style=discord.ButtonStyle.primary
    )

    async def button_share_contact_callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
                description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        await interaction.response.send_modal(TreoShareContactModal())

    button_share_contact.callback = button_share_contact_callback

    button_share_link = Button(
        label="Treo Share Link",
        style=discord.ButtonStyle.secondary
    )

    async def button_share_link_callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
                description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        await interaction.response.send_modal(TreoShareLinkModal())

    button_share_link.callback = button_share_link_callback

    view = View(timeout=None)
    view.add_item(button_thuong)
    view.add_item(button_share_contact)
    view.add_item(button_share_link)

    await ctx.send(embed=embed, view=view)

@bot.command()
@guild_only()
async def nhaypoll(ctx):
    can_use, reason = can_use_commands(ctx.author.id)
    if not can_use:
        embed = discord.Embed(
            title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
            description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y",
            color=0xFF0000
        )
        await ctx.send(embed=embed, delete_after=5)
        return

    embed = discord.Embed(
        title="üìä ** NH√ÇY POLLS ** üìä",
        description=(
            "H·ªá th·ªëng **nh√¢y polls VIP**\n\n"
            "üì¶ **Ch·ª©c nƒÉng:**\n"
            "‚Ä¢ Spam polls t·ª± ƒë·ªông\n"
            "‚Ä¢ T·∫°o hi·ªáu ·ª©ng t∆∞∆°ng t√°c li√™n t·ª•c\n"
            "‚Ä¢ Ho·∫°t ƒë·ªông theo delay c·∫•u h√¨nh\n\n"
            "‚û°Ô∏è Nh·∫•n n√∫t b√™n d∆∞·ªõi ƒë·ªÉ nh·∫≠p th√¥ng tin!"
        ),
        color=0x00FFFF
    )

    embed.add_field(
        name="‚ö° Ch·∫ø ƒê·ªô",
        value="Nh√¢y Polls",
        inline=True
    )

    embed.add_field(
        name="‚è±Ô∏è Delay",
        value="Theo c·∫•u h√¨nh ng∆∞·ªùi d√πng",
        inline=True
    )

    embed.add_field(
        name="üõë D·ª´ng Task",
        value="`!stoptask <ID | all>`",
        inline=True
    )

    embed.add_field(
        name="üîí An To√†n",
        value="Task t·ª± d·ª´ng khi bot restart",
        inline=True
    )
    embed.set_thumbnail(
        url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&"
    )
    embed.set_image(
        url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif"
    )
    embed.set_footer(
        text=" Developed by Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ | GTH Polls System"
    )

    button = Button(label="üìäNh√¢y Polls", style=discord.ButtonStyle.secondary)

    async def button_callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
                description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        await interaction.response.send_modal(PollsModal())

    button.callback = button_callback

    view = View(timeout=None)
    view.add_item(button)

    await ctx.send(embed=embed, view=view)

@bot.command()
@guild_only()
async def setnen(ctx):
    can_use, reason = can_use_commands(ctx.author.id)
    if not can_use:
        embed = discord.Embed(
            title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
            description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y",
            color=0xFF0000
        )
        await ctx.send(embed=embed, delete_after=5)
        return

    embed = discord.Embed(
        title="üé® ** SET THEME BOX ** üé®",
        description=(
            "H·ªá th·ªëng **set theme box t·ª± ƒë·ªông**\n\n"
            "üì¶ **Ch·ª©c nƒÉng:**\n"
            "‚Ä¢ Thay ƒë·ªïi theme / m√†u box\n"
            "‚Ä¢ √Åp d·ª•ng ngay sau khi x√°c nh·∫≠n\n"
            "‚Ä¢ H·ªó tr·ª£ nhi·ªÅu ch·∫ø ƒë·ªô theme\n\n"
            "‚û°Ô∏è Nh·∫•n n√∫t b√™n d∆∞·ªõi ƒë·ªÉ nh·∫≠p th√¥ng tin theme!"
        ),
        color=0x00FFFF
    )

    embed.add_field(
        name="‚ö° Ch·∫ø ƒê·ªô",
        value="Set Theme",
        inline=True
    )

    embed.add_field(
        name="‚è±Ô∏è Delay",
        value="Theo c·∫•u h√¨nh ng∆∞·ªùi d√πng",
        inline=True
    )

    embed.add_field(
        name="üõë D·ª´ng Task",
        value="`!stoptask <ID | all>`",
        inline=True
    )

    embed.add_field(
        name="üîí An To√†n",
        value="Task t·ª± d·ª´ng khi bot restart",
        inline=True
    )
    embed.set_thumbnail(
        url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&"
    )
    embed.set_image(
        url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif"
    )
    embed.set_footer(
        text=" Developed by Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ | Theme System"
    )

    button = Button(label="Set Theme", style=discord.ButtonStyle.secondary)

    async def button_callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
                description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        await interaction.response.send_modal(SetThemeModal())

    button.callback = button_callback

    view = View(timeout=None)
    view.add_item(button)

    await ctx.send(embed=embed, view=view)

@bot.command()
@guild_only()
async def combo(ctx):
    can_use, reason = can_use_commands(ctx.author.id)
    if not can_use:
        embed = discord.Embed(
            title="üö´ Truy C·∫≠p B·ªã T·ª´ Ch·ªëi",
            description="B·∫°n **ch∆∞a ƒë∆∞·ª£c c·∫•p quy·ªÅn** s·ª≠ d·ª•ng Combo",
            color=0xED4245
        )
        embed.set_footer(text="Li√™n h·ªá Admin ƒë·ªÉ m·ªü quy·ªÅn")
        await ctx.send(embed=embed, delete_after=5)
        return

    embed = discord.Embed(
        title="üî• ** COMBO MESSENGER ** üî•",
        description=(
            "H·ªá th·ªëng **Combo Nh√¢y Box** ho·∫°t ƒë·ªông t·ª± ƒë·ªông\n\n"
            "üì¶ **Bao g·ªìm 3 ch·ª©c nƒÉng ch·∫°y song song:**\n"
            "‚Ä¢ üìù Nh√¢y ƒë·ªïi t√™n Box\n"
            "‚Ä¢ üìä Nh√¢y Poll\n"
            "‚Ä¢ üé® Nh√¢y Theme Box\n\n"
            "‚û°Ô∏è Nh·∫•n n√∫t b√™n d∆∞·ªõi ƒë·ªÉ nh·∫≠p th√¥ng tin!"
        ),
        color=0x00FFFF
    )

    embed.add_field(
        name="‚ö° Ch·∫ø ƒê·ªô",
        value="Combo Full Power (3 trong 1)",
        inline=True
    )

    embed.add_field(
        name="‚è±Ô∏è Delay",
        value="√Åp d·ª•ng chung cho t·∫•t c·∫£ ch·ª©c nƒÉng",
        inline=True
    )

    embed.add_field(
        name="üõë D·ª´ng Task",
        value="D√πng l·ªánh `!stoptask <ID | all>`",
        inline=True
    )

    embed.add_field(
        name="üîí An To√†n",
        value="Task t·ª± d·ª´ng khi bot restart",
        inline=True
    )

    embed.set_thumbnail(
        url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&"
    )
    embed.set_image(
        url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif"
    )
    embed.set_footer(
        text=" Developed by Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ | Combo Automation System"
    )

    view = View(timeout=None)

    start_btn = Button(
        label="üöÄ Combo",
        style=discord.ButtonStyle.success
    )

    async def start_callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            await interaction.response.send_message(
                f"‚ùå {reason}", ephemeral=True
            )
            return

        await interaction.response.send_modal(ComboNhayModal())

    start_btn.callback = start_callback
    view.add_item(start_btn)

    await ctx.send(embed=embed, view=view)

@bot.command()
@guild_only()
async def combovip(ctx):
    can_use, reason = can_use_commands(ctx.author.id)
    if not can_use:
        embed = discord.Embed(
            title="üö´ Truy C·∫≠p B·ªã T·ª´ Ch·ªëi",
            description="B·∫°n **ch∆∞a ƒë∆∞·ª£c c·∫•p quy·ªÅn** s·ª≠ d·ª•ng Combo VIP",
            color=0xED4245
        )
        embed.set_footer(text="Li√™n h·ªá Admin ƒë·ªÉ m·ªü quy·ªÅn")
        await ctx.send(embed=embed, delete_after=5)
        return

    embed = discord.Embed(
        title="üíé **COMBO VIP** üíé",
        description=(
            "Combo VIP l√† ch·∫ø ƒë·ªô **n√¢ng cao**, ch·∫°y **4 ch·ª©c nƒÉng c√πng l√∫c**\n\n"
            "üì¶ **Bao g·ªìm:**\n"
            "‚Ä¢ üìù Nh√¢y ƒë·ªïi t√™n Box\n"
            "‚Ä¢ üìä Nh√¢y Poll\n"
            "‚Ä¢ üé® Nh√¢y Theme Box\n"
            "‚Ä¢ üìå Treo tin nh·∫Øn li√™n t·ª•c\n\n"
            "‚û°Ô∏è Nh·∫•n n√∫t b√™n d∆∞·ªõi ƒë·ªÉ nh·∫≠p th√¥ng tin!"
        ),
        color=0xF1C40F
    )

    embed.add_field(
        name="‚ö° Ch·∫ø ƒê·ªô",
        value="Combo VIP ‚Ä¢ Full Power",
        inline=True
    )

    embed.add_field(
        name="üõë D·ª´ng Task",
        value="D√πng `!stoptask <ID | all>`",
        inline=True
    )

    embed.add_field(
        name="üîí An To√†n",
        value="T·ª± d·ª´ng khi bot restart",
        inline=True
    )

    embed.set_thumbnail(
        url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&"
    )
    embed.set_image(
        url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif"
    )
    embed.set_footer(
        text=" Developed by Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ |Combo VIP Automation System"
    )

    view = View(timeout=None)

    start_btn = Button(
        label="üöÄ Combo VIP",
        style=discord.ButtonStyle.success
    )

    async def start_callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            await interaction.response.send_message(
                f"‚ùå {reason}", ephemeral=True
            )
            return

        await interaction.response.send_modal(ComboVipModal())

    start_btn.callback = start_callback
    view.add_item(start_btn)

    await ctx.send(embed=embed, view=view)

@bot.command()
@guild_only()
async def vippro(ctx):
    can_use, reason = can_use_commands(ctx.author.id)
    if not can_use:
        embed = discord.Embed(
            title="üö´ Truy C·∫≠p B·ªã T·ª´ Ch·ªëi",
            description="B·∫°n **ch∆∞a ƒë∆∞·ª£c c·∫•p quy·ªÅn** s·ª≠ d·ª•ng Combo Vippro",
            color=0xED4245
        )
        embed.set_footer(text="Li√™n h·ªá Admin ƒë·ªÉ m·ªü quy·ªÅn")
        await ctx.send(embed=embed, delete_after=5)
        return

    embed = discord.Embed(
        title="üíé ** COMBO VIPPRO ** üíé",
        description=(
            "Vippro l√† ch·∫ø ƒë·ªô **cao c·∫•p**, ch·∫°y **5 ch·ª©c nƒÉng**\n\n"
            "üì¶ **Bao g·ªìm:**\n"
            "‚Ä¢ üìù Nh√¢y ƒë·ªïi t√™n Box\n"
            "‚Ä¢ üîÑ Nh√¢y ƒë·ªïi t√™n th√†nh vi√™n \n"
            "‚Ä¢ üìä Nh√¢y Poll\n"
            "‚Ä¢ üé® Nh√¢y Theme Box\n"
            "‚Ä¢ üìå Treo tin nh·∫Øn li√™n t·ª•c\n\n"
            "‚û°Ô∏è Nh·∫•n n√∫t b√™n d∆∞·ªõi ƒë·ªÉ nh·∫≠p th√¥ng tin!"
        ),
        color=0xF1C40F
    )

    embed.add_field(
        name="‚ö° Ch·∫ø ƒê·ªô",
        value="Vippro ‚Ä¢ Full Power",
        inline=True
    )

    embed.add_field(
        name="üõë D·ª´ng Task",
        value="D√πng `!stoptask <ID | all>`",
        inline=True
    )

    embed.add_field(
        name="üîí An To√†n",
        value="T·ª± d·ª´ng khi bot restart",
        inline=True
    )

    embed.set_thumbnail(
        url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&"
    )
    embed.set_image(
        url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif"
    )
    embed.set_footer(
        text="Developed by Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ | Combo Vippro Automation System"
    )

    view = View(timeout=None)

    start_btn = Button(
        label="üöÄ Combo Vippro",
        style=discord.ButtonStyle.success
    )

    async def start_callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            await interaction.response.send_message(
                f"‚ùå {reason}", ephemeral=True
            )
            return

        await interaction.response.send_modal(VipproModal())

    start_btn.callback = start_callback
    view.add_item(start_btn)

    await ctx.send(embed=embed, view=view)

@bot.command()
@guild_only()
async def dis(ctx):
    can_use, reason = can_use_commands(ctx.author.id)
    if not can_use:
        embed = discord.Embed(
            title="üö´ Truy C·∫≠p B·ªã T·ª´ Ch·ªëi",
            description="B·∫°n **ch∆∞a ƒë∆∞·ª£c c·∫•p quy·ªÅn** s·ª≠ d·ª•ng c√°c ch·ª©c nƒÉng Discord",
            color=0xED4245
        )
        embed.set_footer(text="Li√™n h·ªá Admin ƒë·ªÉ m·ªü quy·ªÅn")
        await ctx.send(embed=embed, delete_after=5)
        return

    embed = discord.Embed(
        title="üíé **Discord Control Panel** üíé",
        description=(
            "Vui l√≤ng ch·ªçn ch·ª©c nƒÉng b√™n d∆∞·ªõi ƒë·ªÉ nh·∫≠p th√¥ng tin c·∫ßn thi·∫øt\n"
            "H·ªá th·ªëng **treo ‚Äì nh√¢y ‚Äì nh√¢y tag ‚Äì s·ªõ ‚Äì s·ªõ tag ‚Äì poll** t·ª± ƒë·ªông"
        ),
        color=0x5865F2
    )

    embed.add_field(
        name="üìå Treo Discord",
        value="Treo Ng√¥n Discord Fake Typing",
        inline=True
    )

    embed.add_field(
        name="üí¨ Nh√¢y Discord",
        value="Nh√¢y fake typing",
        inline=True
    )

    embed.add_field(
        name="üè∑Ô∏è Nh√¢y Tag",
        value="Nh√¢y + mention ng∆∞·ªùi d√πng",
        inline=True
    )

    embed.add_field(
        name="üìä Treo Poll",
        value="Poll Si√™u M√∫p C·ª±c Vip",
        inline=True
    )

    embed.add_field(
        name="‚öôÔ∏è Qu·∫£n L√Ω",
        value="D√πng `!stoptask <ID | all>` ƒë·ªÉ d·ª´ng",
        inline=True
    )

    embed.add_field(
        name="üîí An To√†n",
        value="Task t·ª± d·ª´ng khi restart bot",
        inline=True
    )

    embed.set_thumbnail(
        url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&"
    )
    embed.set_image(
        url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif"
    )
    embed.set_footer(
        text="Developed by Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ | Discord Automation System"
    )

    view = View(timeout=None)

    buttons = [
        ("üìå Treo", TreoDiscordModal),
        ("üí¨ Nh√¢y", NhayDiscordModal),
        ("üè∑Ô∏è Tag", NhayTagDiscordModal),
        ("üìä Poll", PollDiscordModal),
    ]

    for label, modal in buttons:
        btn = Button(label=label, style=discord.ButtonStyle.secondary)

        async def callback(interaction: discord.Interaction, modal=modal):
            can_use, reason = can_use_commands(interaction.user.id)
            if not can_use:
                await interaction.response.send_message(
                    f"‚ùå {reason}", ephemeral=True
                )
                return
            await interaction.response.send_modal(modal())

        btn.callback = callback
        view.add_item(btn)

    await ctx.send(embed=embed, view=view)

@bot.command()
@guild_only()
async def nhaydis(ctx):
    can_use, reason = can_use_commands(ctx.author.id)
    if not can_use:
        embed = discord.Embed(
            title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
            description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y",
            color=0xFF0000
        )
        await ctx.send(embed=embed, delete_after=5)
        return

    embed = discord.Embed(
        title="üîî ** H·ªÜ TH·ªêNG NH√ÇY DISCORD ** üîî",
        description=(
            "H·ªá th·ªëng **nh√¢y Discord**\n\n"
            "üì¶ **Ch·ª©c nƒÉng:**\n"
            "‚Ä¢ Nh√¢y tag `@everyone`\n"
            "‚Ä¢ Nh√¢y emoji üíÄüî•ü§°\n"
            "‚Ä¢ Multi token\n"
            "‚Ä¢ T√πy ch·ªânh delay\n\n"
            "‚û°Ô∏è Ch·ªçn ch·∫ø ƒë·ªô b√™n d∆∞·ªõi ƒë·ªÉ nh·∫≠p th√¥ng tin!"
        ),
        color=0x00FFFF
    )

    embed.add_field(
        name="‚ö° Ch·∫ø ƒê·ªô",
        value="Nh√¢y Tag / Nh√¢y Emoji",
        inline=True
    )

    embed.add_field(
        name="‚è±Ô∏è Delay",
        value="Theo c·∫•u h√¨nh ng∆∞·ªùi d√πng",
        inline=True
    )

    embed.add_field(
        name="üõë D·ª´ng Task",
        value="`!stoptask <ID | all>`",
        inline=True
    )

    embed.add_field(
        name="üîí An To√†n",
        value="Task t·ª± d·ª´ng khi bot restart",
        inline=True
    )

    embed.set_thumbnail(
        url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif"
    )
    embed.set_image(
        url="https://media.giphy.com/media/fZdzEHC8sMC0E/giphy.gif"
    )
    embed.set_footer(
        text="Developed by Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ | Nhay Discord System"
    )

    button_tag = Button(
        label="üöÄ Nh√¢y @everyone",
        style=discord.ButtonStyle.danger
    )

    async def button_tag_callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
                    description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y",
                    color=0xFF0000
                ),
                ephemeral=True
            )
            return

        await interaction.response.send_modal(
            NhayTagEveryoneDiscordModal()
        )

    button_tag.callback = button_tag_callback

    button_emoji = Button(
        label="üòà Nh√¢y Emoji",
        style=discord.ButtonStyle.success
    )

    async def button_emoji_callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
                    description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y",
                    color=0xFF0000
                ),
                ephemeral=True
            )
            return

        await interaction.response.send_modal(
            NhayEmojiDiscordModal()
        )

    button_emoji.callback = button_emoji_callback

    view = View(timeout=None)
    view.add_item(button_tag)
    view.add_item(button_emoji)

    await ctx.send(embed=embed, view=view)

@bot.command()
@guild_only()
async def sodis(ctx):
    can_use, reason = can_use_commands(ctx.author.id)
    if not can_use:
        embed = discord.Embed(
            title="üö´ Truy C·∫≠p B·ªã T·ª´ Ch·ªëi",
            description="B·∫°n **ch∆∞a ƒë∆∞·ª£c c·∫•p quy·ªÅn** s·ª≠ d·ª•ng ch·ª©c nƒÉng S·ªõ Discord",
            color=0xED4245
        )
        embed.set_footer(text="Li√™n h·ªá Admin ƒë·ªÉ m·ªü quy·ªÅn")
        await ctx.send(embed=embed, delete_after=5)
        return

    embed = discord.Embed(
        title="üìú **S·ªõ Discord Control Panel** üìú",
        description=(
            "Vui l√≤ng ch·ªçn ch·ª©c nƒÉng b√™n d∆∞·ªõi ƒë·ªÉ nh·∫≠p th√¥ng tin c·∫ßn thi·∫øt!\n"
            "H·ªá th·ªëng **s·ªõ ‚Äì s·ªõ tag**  t·ª± ƒë·ªông ‚Ä¢ an to√†n ‚Ä¢ ·ªïn ƒë·ªãnh"
        ),
        color=0xF1C40F
    )

    embed.add_field(
        name="üìú S·ªõ Discord",
        value="S·ªõ si√™u m√∫p fake typing",
        inline=True
    )

    embed.add_field(
        name="üìúüè∑Ô∏è S·ªõ Tag",
        value="S·ªõ + mention ng∆∞·ªùi d√πng",
        inline=True
    )

    embed.add_field(
        name="‚öôÔ∏è Qu·∫£n L√Ω",
        value="D√πng `!stoptask <ID | all>` ƒë·ªÉ d·ª´ng",
        inline=True
    )

    embed.add_field(
        name="üîí An To√†n",
        value="Task t·ª± d·ª´ng khi restart bot",
        inline=True
    )

    embed.set_thumbnail(
        url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif"
    )

    embed.set_image(
        url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gifw"
    )

    embed.set_footer(
        text="Developed by Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ | S·ªõ Automation System"
    )

    view = View(timeout=None)

    btn_so = Button(
        label="üìú S·ªõ",
        style=discord.ButtonStyle.secondary
    )

    async def so_callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            await interaction.response.send_message(
                f"‚ùå {reason}", ephemeral=True
            )
            return
        await interaction.response.send_modal(SoDiscordModal())

    btn_so.callback = so_callback
    view.add_item(btn_so)

    btn_sotag = Button(
        label="üìúüè∑Ô∏è S·ªõ Tag",
        style=discord.ButtonStyle.secondary
    )

    async def sotag_callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            await interaction.response.send_message(
                f"‚ùå {reason}", ephemeral=True
            )
            return
        await interaction.response.send_modal(SoTagDiscordModal())

    btn_sotag.callback = sotag_callback
    view.add_item(btn_sotag)

    await ctx.send(embed=embed, view=view)

@bot.command()
@guild_only()
async def stoptask(ctx, task_id: str = None):
    if not task_id:
        embed = discord.Embed(
            title="‚ùå Vui L√≤ng Nh·∫≠p ID Tasks !\nV√≠ d·ª•: !stoptask ABC123 ho·∫∑c !stoptask all",
            color=0xFF0000
        )
        await ctx.send(embed=embed)
        return

    user_id = str(ctx.author.id)
    is_vip = user_id in config['ownerID']

    if task_id.lower() == "all":
        if is_vip:
            for tid in list(running_tasks.keys()):
                running_tasks.pop(tid, None)

            if os.path.exists('data'):
                import shutil
                shutil.rmtree('data')
                os.makedirs('data')

            embed = discord.Embed(
                title="‚úÖ ƒê√£ X√≥a To√†n B·ªô Task Th√†nh C√¥ng\nT·∫•t c·∫£ c√°c task ƒë√£ ƒë∆∞·ª£c d·ª´ng v√† x√≥a",
                color=0x00FF00
            )
            await ctx.send(embed=embed)
            return

        if not os.path.exists('data'):
            embed = discord.Embed(
                title="‚ùå B·∫°n ch∆∞a c√≥ task n√†o ƒëang ch·∫°y",
                color=0xFF0000
            )
            await ctx.send(embed=embed)
            return

        user_tasks = []
        for folder in os.listdir('data'):
            folder_path = f"data/{folder}"
            if os.path.isdir(folder_path) and os.path.exists(f"{folder_path}/luutru.txt"):
                try:
                    with open(f"{folder_path}/luutru.txt", "r", encoding="utf-8") as f:
                        content = f.read().strip()
                        parts = content.split(" | ")

                        task_owner = "Unknown"
                        if parts[3] == "nhay_top_tag" and len(parts) >= 7:
                            task_owner = parts[6]
                        elif parts[3] == "treeso" and len(parts) >= 5:
                            task_owner = parts[4]
                        elif len(parts) >= 5:
                            task_owner = parts[4]

                        if task_owner == user_id:
                            user_tasks.append(folder)
                except:
                    continue

        if not user_tasks:
            embed = discord.Embed(
                title="‚ùå B·∫°n ch∆∞a c√≥ task n√†o ƒëang ch·∫°y",
                color=0xFF0000
            )
            await ctx.send(embed=embed)
            return

        deleted_count = 0
        for task_folder in user_tasks:
            try:
                running_tasks.pop(task_folder, None)

                import shutil
                shutil.rmtree(f"data/{task_folder}")
                deleted_count += 1
            except:
                continue

        embed = discord.Embed(
            title=f"‚úÖ ƒê√£ X√≥a To√†n B·ªô Task C·ªßa B·∫°n\nƒê√£ d·ª´ng & x√≥a {deleted_count} task",
            color=0x00FF00
        )
        await ctx.send(embed=embed)
        return

    folder_path = f"data/{task_id}"
    if not os.path.exists(folder_path):
        embed = discord.Embed(
            title="‚ùå Task kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ b·ªã x√≥a",
            color=0xFF0000
        )
        await ctx.send(embed=embed)
        return

    if not is_vip:
        try:
            with open(f"{folder_path}/luutru.txt", "r", encoding="utf-8") as f:
                content = f.read().strip()
                parts = content.split(" | ")

                task_owner = "Unknown"
                if parts[3] == "nhay_top_tag" and len(parts) >= 7:
                    task_owner = parts[6]
                elif parts[3] == "treeso" and len(parts) >= 5:
                    task_owner = parts[4]
                elif len(parts) >= 5:
                    task_owner = parts[4]

                if task_owner != user_id:
                    embed = discord.Embed(
                        title="‚ùå Task n√†y kh√¥ng thu·ªôc v·ªÅ b·∫°n",
                        color=0xFF0000
                    )
                    await ctx.send(embed=embed)
                    return
        except:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng th·ªÉ ƒë·ªçc th√¥ng tin task",
                color=0xFF0000
            )
            await ctx.send(embed=embed)
            return

    try:
        running_tasks.pop(task_id, None)

        import shutil
        shutil.rmtree(folder_path)

        embed = discord.Embed(
            title=f"‚úÖ ƒê√£ D·ª´ng & X√≥a Task Th√†nh C√¥ng\nTask ID: {task_id}",
            color=0x00FF00
        )
        await ctx.send(embed=embed)

    except Exception as e:
        embed = discord.Embed(
            title=f"‚ùå Kh√¥ng th·ªÉ x√≥a task: {str(e)}",
            color=0xFF0000
        )
        await ctx.send(embed=embed)

@bot.command()
@guild_only()
async def listbox(ctx):
    embed = discord.Embed(
        title="üìã L·∫•y Danh S√°ch Box Facebook",
        description="·∫§n V√†o N√∫t **Start** ƒê·ªÉ Nh·∫≠p Cookies",
        color=0xFF69B4,
        timestamp=datetime.datetime.now(datetime.UTC)
    )
    embed.add_field(
        name="üìå H∆∞·ªõng D·∫´n",
        value="‚Ä¢ Nh·∫≠p Cookies Facebook\n‚Ä¢ Bot S·∫Ω T·ª± ƒê·ªông L·∫•y T·∫•t C·∫£ Box C√≥ Trong Cookies\n‚Ä¢ K·∫øt Qu·∫£ S·∫Ω ƒê∆∞·ª£c Hi·ªÉn Th·ªã Theo Trang",
        inline=False
    )
    embed.set_footer(text="Developed By Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ ", icon_url=bot.user.avatar.url if bot.user.avatar else None)
    
    view = ListBoxView()
    await ctx.send(embed=embed, view=view)

class ListBoxModal(discord.ui.Modal):
    def __init__(self):
        super().__init__(title="üç™ Nh·∫≠p Cookies Facebook", timeout=None)
        self.cookies = discord.ui.TextInput(
            label="Cookies Facebook",
            placeholder="Nh·∫≠p Cookies Facebook C·ªßa B·∫°n...",
            style=discord.TextStyle.paragraph,
            required=True,
            max_length=4000
        )
        self.add_item(self.cookies)

    async def on_submit(self, interaction: discord.Interaction):
        loading_embed = discord.Embed(
            title="‚è∞ ƒêang X·ª≠ L√Ω...",
            description="Bot ƒêang L·∫•y List Box, Vui L√≤ng ƒê·ª£i...",
            color=0xFFD700
        )
        await interaction.response.send_message(embed=loading_embed, ephemeral=True)
        
        try:
            # S·ª≠ d·ª•ng FacebookThreadExtractor thay v√¨ facebook v√† fbTools
            extractor = FacebookThreadExtractor(self.cookies.value)
            result = extractor.get_thread_list(limit=50)
            
            if "error" in result:
                error_embed = discord.Embed(
                    title="‚ùå L·ªói Cookies",
                    description="Kh√¥ng Th·ªÉ L·∫•y Danh S√°ch Nh√≥m, Vui L√≤ng Check L·∫°i Cookies.",
                    color=0xFF0000
                )
                await interaction.followup.send(embed=error_embed, ephemeral=False)
                return
            
            # Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu ƒë·ªÉ ph√π h·ª£p v·ªõi giao di·ªán c≈©
            threads = result["threads"]
            thread_ids = [thread["thread_id"] for thread in threads]
            thread_names = [thread["thread_name"] for thread in threads]
            
            if len(thread_ids) > 10:
                pages = []
                for i in range(0, len(thread_ids), 10):
                    page_data = []
                    for j in range(i, min(i + 10, len(thread_ids))):
                        page_data.append({
                            "index": j + 1,
                            "name": thread_names[j],
                            "id": thread_ids[j]
                        })
                    pages.append(page_data)
                
                view = PaginationView(pages, len(thread_ids))
                initial_embed = view.create_embed()
                await interaction.followup.send(embed=initial_embed, view=view, ephemeral=False)
            else:
                embed = discord.Embed(
                    title="üìã Danh S√°ch Box Facebook",
                    color=0x00FF00,
                    timestamp=datetime.datetime.now(datetime.UTC)
                )
                
                description = ""
                for i in range(len(thread_ids)):
                    description += f"**{i+1}.** {thread_names[i]}\n`{thread_ids[i]}`\n\n"
                
                embed.description = description
                embed.set_footer(text=f"T·ªïng C·ªông: {len(thread_ids)} Box")
                
                await interaction.followup.send(embed=embed, ephemeral=False)
                
        except Exception as e:
            error_embed = discord.Embed(
                title="‚ö†Ô∏è ƒê√£ X·∫£y Ra L·ªói",
                description=f"{e}",
                color=0xFF0000
            )
            await interaction.followup.send(embed=error_embed, ephemeral=False)

class ListBoxView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)

    @discord.ui.button(label="Start", style=discord.ButtonStyle.primary, emoji="üöÄ")
    async def start_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = ListBoxModal()
        await interaction.response.send_modal(modal)

class PaginationView(discord.ui.View):
    def __init__(self, pages, total_items):
        super().__init__(timeout=300)
        self.pages = pages
        self.current_page = 0
        self.total_items = total_items

    def create_embed(self):
        embed = discord.Embed(
            title="üìã Danh S√°ch Box Facebook",
            color=0x00FF00,
            timestamp=datetime.datetime.now(datetime.UTC)
        )
        
        current_page_data = self.pages[self.current_page]
        description = ""
        
        for item in current_page_data:
            description += f"**{item['index']}.** {item['name']}\n`{item['id']}`\n\n"
        
        embed.description = description
        
        embed.set_footer(
            text=f"Trang {self.current_page + 1}/{len(self.pages)} ‚Ä¢ T·ªïng C·ªông: {self.total_items} Box"
        )
        
        return embed

    @discord.ui.button(emoji="‚¨ÖÔ∏è", style=discord.ButtonStyle.secondary, disabled=True)
    async def previous_page(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.current_page > 0:
            self.current_page -= 1
            
            self.previous_page.disabled = self.current_page == 0
            self.next_page.disabled = False
            
            embed = self.create_embed()
            await interaction.response.edit_message(embed=embed, view=self)
        else:
            await interaction.response.defer()

    @discord.ui.button(emoji="‚û°Ô∏è", style=discord.ButtonStyle.secondary)
    async def next_page(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.current_page < len(self.pages) - 1:
            self.current_page += 1
            
            self.next_page.disabled = self.current_page == len(self.pages) - 1
            self.previous_page.disabled = False
            
            embed = self.create_embed()
            await interaction.response.edit_message(embed=embed, view=self)
        else:
            await interaction.response.defer()

    @discord.ui.button(label="ƒê√≥ng", emoji="‚ùå", style=discord.ButtonStyle.danger)
    async def close_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="‚úÖ ƒê√£ ƒê√≥ng",
            description="Danh S√°ch ƒê√£ ƒê∆∞·ª£c ƒê√≥ng",
            color=0x808080
        )
        await interaction.response.edit_message(embed=embed, view=None)

    async def on_timeout(self):
        for item in self.children:
            item.disabled = True

# Th√™m c√°c import c·∫ßn thi·∫øt v√† FacebookThreadExtractor class
import requests
import json
import time
import random
import re

def get_facebook_id_from_cookie(cookie):
    try:
        c_user_match = re.search(r"c_user=(\d+)", cookie)
        return c_user_match.group(1) if c_user_match else "Unknown"
    except:
        return "Unknown"

class FacebookThreadExtractor:
    def __init__(self, cookie):
        self.cookie = cookie
        self.session = requests.Session()
        self.user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36"
        ]
        self.facebook_tokens = {}

    def get_facebook_tokens(self):
        headers = {
            'Cookie': self.cookie,
            'User-Agent': random.choice(self.user_agents),
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.9,vi;q=0.8',
            'Sec-Fetch-Dest': 'document',
            'Sec-Fetch-Mode': 'navigate',
            'Sec-Fetch-Site': 'none',
            'Sec-Fetch-User': '?1',
            'Upgrade-Insecure-Requests': '1'
        }

        sites = ['https://www.facebook.com', 'https://mbasic.facebook.com']
        for site in sites:
            try:
                response = self.session.get(site, headers=headers, timeout=10)
                c_user_match = re.search(r"c_user=(\d+)", self.cookie)
                if c_user_match:
                    self.facebook_tokens["FacebookID"] = c_user_match.group(1)

                fb_dtsg_match = re.search(r'"token":"(.*?)"', response.text)
                if not fb_dtsg_match:
                    fb_dtsg_match = re.search(r'name="fb_dtsg" value="(.*?)"', response.text)
                if fb_dtsg_match:
                    self.facebook_tokens["fb_dtsg"] = fb_dtsg_match.group(1)

                jazoest_match = re.search(r'jazoest=(\d+)', response.text)
                if jazoest_match:
                    self.facebook_tokens["jazoest"] = jazoest_match.group(1)

                revision_match = re.search(r'client_revision":(\d+)', response.text)
                if revision_match:
                    self.facebook_tokens["client_revision"] = revision_match.group(1)

                if self.facebook_tokens.get("fb_dtsg") and self.facebook_tokens.get("jazoest"):
                    break
            except:
                continue

        self.facebook_tokens.update({
            "__rev": "1015919737",
            "__req": "1b",
            "__a": "1",
            "__comet_req": "15"
        })

        return len(self.facebook_tokens) > 4

    def get_thread_list(self, limit=20):
        if not self.get_facebook_tokens():
            return {"error": "Kh√¥ng th·ªÉ l·∫•y token t·ª´ Facebook. Ki·ªÉm tra l·∫°i cookie."}

        form_data = {
            "av": self.facebook_tokens.get("FacebookID", ""),
            "__user": self.facebook_tokens.get("FacebookID", ""),
            "__a": self.facebook_tokens["__a"],
            "__req": self.facebook_tokens["__req"],
            "__hs": "19234.HYP:comet_pkg.2.1..2.1",
            "dpr": "1",
            "__ccg": "EXCELLENT",
            "__rev": self.facebook_tokens["__rev"],
            "__comet_req": self.facebook_tokens["__comet_req"],
            "fb_dtsg": self.facebook_tokens.get("fb_dtsg", ""),
            "jazoest": self.facebook_tokens.get("jazoest", ""),
            "lsd": "null",
            "__spin_r": self.facebook_tokens.get("client_revision", ""),
            "__spin_b": "trunk",
            "__spin_t": str(int(time.time())),
        }

        queries = {
            "o0": {
                "doc_id": "3336396659757871",
                "query_params": {
                    "limit": limit,
                    "before": None,
                    "tags": ["INBOX"],
                    "includeDeliveryReceipts": False,
                    "includeSeqID": True,
                }
            }
        }

        form_data["queries"] = json.dumps(queries)

        headers = {
            'Cookie': self.cookie,
            'User-Agent': random.choice(self.user_agents),
            'Content-Type': 'application/x-www-form-urlencoded',
            'Accept': '*/*',
            'Accept-Language': 'en-US,en;q=0.9,vi;q=0.8',
            'Origin': 'https://www.facebook.com',
            'Referer': 'https://www.facebook.com/',
            'Sec-Fetch-Dest': 'empty',
            'Sec-Fetch-Mode': 'cors',
            'Sec-Fetch-Site': 'same-origin',
            'X-FB-Friendly-Name': 'MessengerThreadListQuery',
            'X-FB-LSD': 'null'
        }

        try:
            response = self.session.post(
                'https://www.facebook.com/api/graphqlbatch/',
                data=form_data,
                headers=headers,
                timeout=15
            )

            if response.status_code != 200:
                return {"error": f"HTTP Error: {response.status_code}"}

            response_text = response.text.split('{"successful_results"')[0]
            data = json.loads(response_text)

            if "o0" not in data:
                return {"error": "Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu thread list"}

            if "errors" in data["o0"]:
                return {"error": f"Facebook API Error: {data['o0']['errors'][0]['summary']}"}

            threads = data["o0"]["data"]["viewer"]["message_threads"]["nodes"]
            thread_list = []

            for thread in threads:
                if not thread.get("thread_key") or not thread["thread_key"].get("thread_fbid"):
                    continue

                thread_info = {
                    "thread_id": thread["thread_key"]["thread_fbid"],
                    "thread_name": thread.get("name", "Kh√¥ng c√≥ t√™n"),
                    "message_count": thread.get("messages_count", 0),
                    "participant_count": len(thread.get("all_participants", {}).get("edges", []))
                }

                thread_list.append(thread_info)

            return {
                "success": True,
                "thread_count": len(thread_list),
                "threads": thread_list,
                "facebook_id": self.facebook_tokens.get("FacebookID", "Unknown")
            }

        except json.JSONDecodeError as e:
            return {"error": f"L·ªói parse JSON: {str(e)}"}
        except Exception as e:
            return {"error": f"L·ªói kh√¥ng x√°c ƒë·ªãnh: {str(e)}"}

@bot.command()
@guild_only()
async def danhsachtask(ctx):
    user_id = str(ctx.author.id)
    tasks = []

    if os.path.exists('data'):
        for folder in os.listdir('data'):
            folder_path = f"data/{folder}"
            if os.path.isdir(folder_path) and os.path.exists(f"{folder_path}/luutru.txt"):
                try:
                    with open(f"{folder_path}/luutru.txt", "r", encoding="utf-8") as f:
                        content = f.read().strip()
                        parts = content.split(" | ")
                        
                        if len(parts) >= 5:
                            task_owner = parts[4]
                            if task_owner == user_id:
                                created_timestamp = os.path.getctime(folder_path)
                                created_time = datetime.datetime.fromtimestamp(created_timestamp).strftime("%d-%m-%Y %H:%M")
                                task_type = parts[3]
                                
                                if task_type == "nhay_tag":
                                    task_info = f"**ID Task:** {folder}\n**Type:** Nh√¢y Tag\n**Box ID:** {parts[1]}\n**Delay:** {parts[2]}s\n**Created:** {created_time}\n"
                                elif task_type == "nhay_thuong":
                                    task_info = f"**ID Task:** {folder}\n**Type:** Nh√¢y Th∆∞·ªùng\n**Box ID:** {parts[1]}\n**Delay:** {parts[2]}s\n**Created:** {created_time}\n"
                                elif task_type == "treeso":
                                    task_info = f"**ID Task:** {folder}\n**Type:** Treo S·ªõ\n**Box ID:** {parts[1]}\n**Delay:** {parts[2]}s\n**Created:** {created_time}\n"
                                elif task_type == "treo":
                                    task_info = f"**ID Task:** {folder}\n**Type:** Treo Mess\n**Box ID:** {parts[1]}\n**Delay:** {parts[2]}s\n**Created:** {created_time}\n"
                                elif task_type == "nhaypoll":
                                    task_info = f"**ID Task:** {folder}\n**Type:** Nh√¢y Polls\n**Box ID:** {parts[1]}\n**Delay:** {parts[2]}s\n**Created:** {created_time}\n"
                                elif task_type == "set_theme":
                                    task_info = f"**ID Task:** {folder}\n**Type:** Set Theme\n**Box ID:** {parts[1]}\n**Delay:** {parts[2]}s\n**Created:** {created_time}\n"
                                elif task_type == "raid_continuous":
                                    task_info = f"**ID Task:** {folder}\n**Type:** Raid Box Li√™n T·ª•c\n**Box ID:** {parts[1]}\n**Delay:** {parts[2]}s\n**Created:** {created_time}\n"
                                elif task_type == "treo_share_contact":
                                    task_info = f"**ID Task:** {folder}\n**Type:** Treo Share Contact\n**Box ID:** {parts[1]}\n**Delay:** {parts[2]}s\n**Created:** {created_time}\n"
                                elif task_type == "treo_share_link":
                                    task_info = f"**ID Task:** {folder}\n**Type:** Treo Share Link\n**Box ID:** {parts[1]}\n**Delay:** {parts[2]}s\n**Created:** {created_time}\n"
                                else:
                                    task_info = f"**ID Task:** {folder}\n**Type:** {task_type}\n**Created:** {created_time}\n"
                                
                                tasks.append(task_info)
                except Exception:
                    continue

    if not tasks:
        embed = discord.Embed(
            title="‚ùå B·∫°n ch∆∞a c√≥ task n√†o ƒëang ch·∫°y",
            description="",
            color=0xFF0000
        )
        await ctx.send(embed=embed)
        return

    tasks_per_page = 5
    total_pages = (len(tasks) + tasks_per_page - 1) // tasks_per_page
    current_page = 1

    def create_embed(page):
        start_idx = (page - 1) * tasks_per_page
        end_idx = start_idx + tasks_per_page
        page_tasks = tasks[start_idx:end_idx]
        
        description = "\n".join([f"**{i+start_idx+1}.** {task}" for i, task in enumerate(page_tasks)])
        
        embed = discord.Embed(
            title="üìù Danh S√°ch Task",
            description=description,
            color=0x0099FF
        )
        
        embed.set_footer(text=f"Trang {page}/{total_pages} ‚Ä¢ T·ªïng: {len(tasks)} task")
        return embed

    embed = create_embed(current_page)
    await ctx.send(embed=embed)

@bot.command()
async def snipe(ctx):
    await del_cmd(ctx)
    data = snipe_data.get(ctx.channel.id)
    if not data:
        return await ctx.send("‚ùå Kh√¥ng c√≥ tin nh·∫Øn b·ªã x√≥a g·∫ßn ƒë√¢y")

    embed = discord.Embed(description=data["content"], color=0x00ff00)
    embed.set_author(name=data["author"], icon_url=data["avatar"])
    embed.set_footer(text=f"üïí {data['time']}")
    await ctx.send(embed=embed)

@bot.command()
async def uptime(ctx):
    await del_cmd(ctx)
    uptime = str(datetime.timedelta(seconds=int(time.time() - start_time)))
    await ctx.send(f"‚è≥ Uptime: `{uptime}`")

@bot.command()
async def ping(ctx):
    await del_cmd(ctx)
    await ctx.send(f"üèì Pong `{round(bot.latency*1000)}ms`")

@bot.command()
async def listid(ctx):
    await del_cmd(ctx)
    if not ctx.guild:
        return await ctx.send("‚ùå L·ªánh n√†y ch·ªâ d√πng trong server")

    channels = [f"{c.name}: `{c.id}`" for c in ctx.guild.text_channels]
    result = "\n".join(channels)

    if len(result) > 1900:
        result = result[:1900] + "..."

    await ctx.send(f"üìÇ **DANH S√ÅCH ID K√äNH:**\n{result}", delete_after=30)

@bot.command()
async def ghost(ctx, *, text: str):
    await del_cmd(ctx)
    msg = await ctx.send(text)
    await asyncio.sleep(1)
    await msg.delete()

@bot.command()
async def bank(ctx):
    await del_cmd(ctx)
    try:
        embed = discord.Embed(
            title="üí≥ TH√îNG TIN CHUY·ªÇN KHO·∫¢N MBBANK",
            color=0x0054a6
        )
        embed.add_field(name="CH·ª¶ T√ÄI KHO·∫¢N", value=TEN_CHUTK, inline=True)
        embed.add_field(name="S·ªê T√ÄI KHO·∫¢N", value=f"`{STK}`", inline=True)
        embed.set_image(url=QR_FIXED_URL)
        embed.set_thumbnail(url=THUMBNAIL_URL)
        await ctx.send(embed=embed)
    except:
        await ctx.send(
            f"üí≥ **MBBANK:** `{STK}`\n"
            f"üë§ `**{TEN_CHUTK}**`\n"
            f"{QR_FIXED_URL}"
        )

@bot.command()
async def av(ctx, user: discord.User = None):
    await del_cmd(ctx)
    user = user or ctx.author
    
    embed = discord.Embed(
        title="üñºÔ∏è Avatar",
        description=f"Avatar c·ªßa {user.mention}",
        color=discord.Color.blue()
    )
    embed.set_image(url=user.avatar.url if user.avatar else None)
    await ctx.send(embed=embed)

@bot.command()
async def infouser(ctx, user: discord.Member = None):
    await del_cmd(ctx)
    user = user or ctx.author

    embed = discord.Embed(
        title="üë§ Th√¥ng tin ng∆∞·ªùi d√πng",
        description=f"{user.mention}",
        color=discord.Color.green()
    )
    embed.add_field(name="T√™n", value=f"{user.name}#{user.discriminator}", inline=False)
    embed.add_field(name="üÜî ID", value=f"`{user.id}`", inline=False)
    embed.add_field(name="üìÖ Ng√†y t·∫°o", value=user.created_at.strftime('%d/%m/%Y'), inline=True)
    embed.add_field(name="üì• Ng√†y tham gia", value=user.joined_at.strftime('%d/%m/%Y'), inline=True)
    embed.add_field(name="üé≠ Vai tr√≤ cao nh·∫•t", value=user.top_role.mention, inline=False)
    embed.set_thumbnail(url=user.avatar.url if user.avatar else None)
    await ctx.send(embed=embed)

@bot.command()
async def infosrv(ctx):
    await del_cmd(ctx)
    if not ctx.guild:
        return await ctx.send("‚ùå L·ªánh n√†y ch·ªâ d√πng trong server")

    g = ctx.guild
    embed = discord.Embed(
        title="üè∞ Th√¥ng tin m√°y ch·ªß",
        description=g.name,
        color=discord.Color.gold()
    )
    embed.add_field(name="üÜî ID", value=f"`{g.id}`", inline=False)
    embed.add_field(name="üëë Ch·ªß s·ªü h·ªØu", value=g.owner.mention, inline=False)
    embed.add_field(name="üë• Th√†nh vi√™n", value=str(g.member_count), inline=True)
    embed.add_field(name="üìÖ Ng√†y t·∫°o", value=g.created_at.strftime('%d/%m/%Y'), inline=True)
    embed.set_thumbnail(url=g.icon.url if g.icon else None)
    await ctx.send(embed=embed)

@bot.command()
async def dm(ctx, user: discord.User, *, text: str):
    await del_cmd(ctx)
    try:
        await user.send(text)
        await ctx.send(f"‚úÖ ƒê√£ g·ª≠i DM cho {user.name}", delete_after=3)
    except:
        await ctx.send("‚ùå Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn cho ng∆∞·ªùi n√†y!", delete_after=5)

@bot.command()
async def roll(ctx):
    await del_cmd(ctx)
    embed = discord.Embed(
        title="üé≤ X√∫c x·∫Øc",
        description=f"S·ªë may m·∫Øn c·ªßa b·∫°n: `{random.randint(1, 18)}`",
        color=discord.Color.purple()
    )
    await ctx.send(embed=embed)

@bot.command()
async def coin(ctx):
    await del_cmd(ctx)
    result = random.choice(['S·∫§P', 'NG·ª¨A'])
    embed = discord.Embed(
        title="ü™ô Tung ƒë·ªìng xu",
        description=f"K·∫øt qu·∫£: `{result}`",
        color=discord.Color.orange()
    )
    await ctx.send(embed=embed)

@bot.command()
async def hug(ctx, user: discord.User):
    await send_action(ctx, user, "hug")

@bot.command()
async def slap(ctx, user: discord.User):
    await send_action(ctx, user, "slap")

@bot.command()
async def kill(ctx, user: discord.User):
    await send_action(ctx, user, "kill")

@bot.command()
async def kiss(ctx, user: discord.User):
    await send_action(ctx, user, "kiss")

@bot.command()
async def bold(ctx, *, text: str):
    await del_cmd(ctx)
    embed = discord.Embed(
        title="**Text in bold**",
        description=f"**{text}**",
        color=discord.Color.blue()
    )
    await ctx.send(embed=embed)

@bot.command()
async def spoiler(ctx, *, text: str):
    await del_cmd(ctx)
    embed = discord.Embed(
        title="||Spoiler Text||",
        description=f"||{text}||",
        color=discord.Color.dark_gray()
    )
    await ctx.send(embed=embed)

@bot.command()
async def say(ctx, *, text: str):
    await del_cmd(ctx)
    embed = discord.Embed(
        title="Say",
        description=text,
        color=discord.Color.teal()
    )
    await ctx.send(embed=embed)

@bot.command()
async def bigsay(ctx, *, text: str):
    await del_cmd(ctx)
    embed = discord.Embed(
        title="Big Say",
        description=f"# {text}",
        color=discord.Color.dark_orange()
    )
    await ctx.send(embed=embed)

@bot.command()
@guild_only()
async def setfile(ctx):
    can_use, reason = can_use_commands(ctx.author.id)
    if not can_use:
        await ctx.send("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn d√πng l·ªánh n√†y", delete_after=5)
        return

    if not ctx.message.attachments:
        await ctx.send("‚ùå G·ª≠i k√®m file **.mp3**", delete_after=5)
        return

    file = ctx.message.attachments[0]

    if not file.filename.lower().endswith(".mp3"):
        await ctx.send("‚ùå Ch·ªâ nh·∫≠n file **.mp3**", delete_after=5)
        return

    path = os.path.join(MUSIC_FOLDER, file.filename)
    await file.save(path)

    await ctx.send(f"‚úÖ ƒê√£ l∆∞u nh·∫°c: `music/{file.filename}`")

@bot.command()
@guild_only()
async def xa(ctx):
    can_use, reason = can_use_commands(ctx.author.id)
    if not can_use:
        embed = discord.Embed(
            title="üö´ Truy C·∫≠p B·ªã T·ª´ Ch·ªëi",
            description="B·∫°n ch∆∞a ƒë∆∞·ª£c c·∫•p quy·ªÅn d√πng X·∫£ Nh·∫°c",
            color=0xED4245
        )
        await ctx.send(embed=embed, delete_after=5)
        return

    embed = discord.Embed(
        title="üé∂ X·∫¢ CONTROL PANEL",
        description=(
            "X·∫£ nh·∫°c voice Discord b·∫±ng **TASK SYSTEM**\n"
            "‚Ä¢ L·∫∑p v√¥ h·∫°n ‚Ä¢ ·ªîn ƒë·ªãnh ‚Ä¢ An to√†n\n\n"
            "‚õî D·ª´ng b·∫±ng `!stoptask <ID | all>`"
        ),
        color=0x9B59B6
    )

    embed.add_field(
        name="üé∂ X·∫£",
        value="Ph√°t nh·∫°c l·∫∑p v√¥ h·∫°n",
        inline=True
    )

    embed.add_field(
        name="‚öôÔ∏è Qu·∫£n L√Ω",
        value="Task-based system",
        inline=True
    )

    embed.set_thumbnail(
        url="https://cdn.discordapp.com/attachments/1439081083151847548/1463730561611857950/giphy.gif?ex=6978d390&is=69778210&hm=55b17f22214efa60311056b281bd1938cd607c0fc6ecbba8007a73cd0ff1f0d3&"
    )
    embed.set_image(
        url="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3kxbzA5cDJhejdleHdrejlwNGNobWhuZWlyODg3ZGUyZDF0MTFsZyZlcD12MV9naWZzX3NlYXJjaCZjdD1n/fZdzEHC8sMC0E/giphy.gif"
    )
    embed.set_footer(text="Developed by Yan Cte ‚ãÜ‚≠íÀö.‚ãÜ | Music Task System")

    view = View(timeout=None)

    btn = Button(
        label="üé∂ X·∫£",
        style=discord.ButtonStyle.secondary
    )

    async def callback(interaction: discord.Interaction):
        can_use, reason = can_use_commands(interaction.user.id)
        if not can_use:
            await interaction.response.send_message(
                f"‚ùå {reason}", ephemeral=True
            )
            return
        await interaction.response.send_modal(XaNhacModal())

    btn.callback = callback
    view.add_item(btn)

    await ctx.send(embed=embed, view=view)

# ===== MODAL CLASSES (S·ª¨A KI·ªÇM TRA QUY·ªÄN) =====
class namechangeModal(Modal, title="Set Name T·∫•t C·∫£ Th√†nh Vi√™n"):
    cookie = TextInput(label="Cookie Facebook", placeholder="Nh·∫≠p Cookie Facebook", required=True)
    thread_id = TextInput(label="ID BOX", placeholder="123456789", required=True)
    nickname = TextInput(label="T√™n c·∫ßn ƒë·ªïi", placeholder="B√© Y√™u, C√¥ng Ch√∫a, Ho√†ng T·ª≠...", required=True, style=discord.TextStyle.paragraph)
    delay = TextInput(label="Delay (gi√¢y)", placeholder="5", required=False, default="5")

    async def on_submit(self, interaction: discord.Interaction):
        can_create, task_info = can_create_task(interaction.user.id)
        if not can_create:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng th·ªÉ t·∫°o task!",
                description=f"**L√Ω do:** {task_info}",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        # X·ª≠ l√Ω danh s√°ch t√™n
        nicknames_input = self.nickname.value.strip()
        nicknames = [nick.strip() for nick in nicknames_input.split(',')]
        nicknames = [nick for nick in nicknames if nick]  # Lo·∫°i b·ªè chu·ªói r·ªóng

        if not nicknames:
            embed = discord.Embed(
                title="‚ùå Danh s√°ch t√™n kh√¥ng h·ª£p l·ªá!",
                description="Vui l√≤ng nh·∫≠p √≠t nh·∫•t m·ªôt t√™n",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        folder_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(6))
        folder_path = f"data/{folder_id}"
        os.makedirs(folder_path)

        # L∆∞u th√¥ng tin task
        with open(f"{folder_path}/luutru.txt", "w", encoding="utf-8") as f:
            nicknames_str = ','.join(nicknames)
            f.write(f"{self.cookie.value.strip()} | {self.thread_id.value.strip()} | {self.delay.value.strip()} | namechange | {interaction.user.id} | {nicknames_str}")

        # Ch·∫°y task
        delay_value = 5
        try:
            delay_value = int(self.delay.value.strip()) if self.delay.value.strip() else 5
        except ValueError:
            delay_value = 5

        thread = threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_namechange_task,
                self.cookie.value.strip(),
                self.thread_id.value.strip(),
                nicknames,
                float(delay_value),
                folder_id
            ),
            daemon=True
        )
        thread.start()

        embed = discord.Embed(
            title="‚úÖ T·∫°o Tasks Th√†nh C√¥ng ‚úÖ",
            description=f"ID Tasks: `{folder_id}`",
            color=0x00FF00
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
class namechangeModal(Modal, title="Set Name T·∫•t C·∫£ Th√†nh Vi√™n"):
    cookie = TextInput(
        label="Cookie Facebook",
        placeholder="Nh·∫≠p Cookie Facebook",
        required=True
    )
    thread_id = TextInput(
        label="ID BOX",
        placeholder="123456789",
        required=True
    )
    delay = TextInput(
        label="Delay (gi√¢y)",
        placeholder="5",
        required=False,
        default="5"
    )

    async def on_submit(self, interaction: discord.Interaction):
        can_create, task_info = can_create_task(interaction.user.id)
        if not can_create:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng th·ªÉ t·∫°o task!",
                description=f"**L√Ω do:** {task_info}",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        if not os.path.exists("nhay.txt"):
            embed = discord.Embed(
                title="‚ùå Thi·∫øu file nhay.txt",
                description="Kh√¥ng t√¨m th·∫•y file nhay.txt",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        with open("nhay.txt", "r", encoding="utf-8") as f:
            nicknames = [line.strip() for line in f if line.strip()]

        if not nicknames:
            embed = discord.Embed(
                title="‚ùå L·ªói nickname",
                description="File nhay.txt kh√¥ng c√≥ d·ªØ li·ªáu",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        folder_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(6))
        folder_path = f"data/{folder_id}"
        os.makedirs(folder_path)

        with open(f"{folder_path}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(
                f"{self.cookie.value.strip()} | "
                f"{self.thread_id.value.strip()} | "
                f"{self.delay.value.strip()} | "
                f"namechange | "
                f"{interaction.user.id}"
            )

        try:
            delay_value = float(self.delay.value.strip()) if self.delay.value.strip() else 5
        except ValueError:
            delay_value = 5

        thread = threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_namechange_task,
                self.cookie.value.strip(),
                self.thread_id.value.strip(),
                nicknames,
                delay_value,
                folder_id
            ),
            daemon=True
        )
        thread.start()

        embed = discord.Embed(
            title="‚úÖ T·∫°o Task Th√†nh C√¥ng",
            description=f"ID Task: `{folder_id}`",
            color=0x00FF00
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)

class NhayNameBoxModal(Modal, title="Nh√¢y ƒê·ªïi T√™n Box"):
    cookie = TextInput(label="Cookie Facebook", placeholder="Nh·∫≠p Cookie Facebook", required=True)
    thread_id = TextInput(label="ID BOX", placeholder="123456789", required=True)
    delay = TextInput(label="Delay (gi√¢y)", placeholder="5", required=False, default="5")

    async def on_submit(self, interaction: discord.Interaction):
        can_create, task_info = can_create_task(interaction.user.id)
        if not can_create:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng th·ªÉ t·∫°o task!",
                description=f"**L√Ω do:** {task_info}",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        folder_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(6))
        folder_path = f"data/{folder_id}"
        os.makedirs(folder_path)

        with open(f"{folder_path}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(f"{self.cookie.value.strip()} | {self.thread_id.value.strip()} | {self.delay.value.strip()} | nhay_name_box | {interaction.user.id}")

        thread = threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_nhay_name_box_task,
                self.cookie.value.strip(),
                self.thread_id.value.strip(),
                float(self.delay.value.strip()) if self.delay.value.strip().replace('.', '').isdigit() else 5.0,
                folder_id
            ),
            daemon=True
        )
        thread.start()

        embed = discord.Embed(
            title="‚úÖ T·∫°o Tasks Th√†nh C√¥ng ‚úÖ",
            description=f"ID Tasks: `{folder_id}`",
            color=0x00FF00
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)

class RaiderModal(Modal, title="Raid Box"):
    cookie = TextInput(label="Cookie", placeholder="Nh·∫≠p Cookie Facebook", required=True)
    box_id = TextInput(label="ID Nh√≥m", placeholder="123456789", required=True)
    group_name = TextInput(label="T√™n nh√≥m c·∫ßn ƒë·ªïi", placeholder="T√™n nh√≥m m·ªõi", required=True)
    delay = TextInput(label="Delay (gi√¢y)", placeholder="3", required=False, default="3")

    async def on_submit(self, interaction: discord.Interaction):
        can_create, task_info = can_create_task(interaction.user.id)
        if not can_create:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng th·ªÉ t·∫°o task!",
                description=f"**L√Ω do:** {task_info}",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        # Ch·ªâ th·ª±c hi·ªán raid m·ªôt l·∫ßn
        await interaction.response.send_message("Loading...")
        threading.Thread(
            target=run_raider_once,
            args=(
                self.cookie.value.strip(),
                self.box_id.value.strip(),
                self.group_name.value.strip(),
                int(self.delay.value.strip()) if self.delay.value.strip().isdigit() else 3,
                interaction.channel
            ),
            daemon=True
        ).start()

class NhayThuongModal(Modal, title="Nh√¢y Th∆∞·ªùng - Fake Typing"):
    cookie = TextInput(label="Cookie Facebook", placeholder="Nh·∫≠p Cookie Facebook", required=True)
    thread_id = TextInput(label="ID BOX", placeholder="123456789", required=True)
    delay = TextInput(label="Delay (gi√¢y)", placeholder="5", required=False, default="5")

    async def on_submit(self, interaction: discord.Interaction):
        can_create, task_info = can_create_task(interaction.user.id)
        if not can_create:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng th·ªÉ t·∫°o task!",
                description=f"**L√Ω do:** {task_info}",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        folder_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(6))
        folder_path = f"data/{folder_id}"
        os.makedirs(folder_path)

        with open(f"{folder_path}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(f"{self.cookie.value.strip()} | {self.thread_id.value.strip()} | {self.delay.value.strip()} | nhay_thuong | {interaction.user.id}")

        thread = threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_nhay_thuong_task,
                self.cookie.value.strip(),
                self.thread_id.value.strip(),
                float(self.delay.value.strip()) if self.delay.value.strip().replace('.', '').isdigit() else 5.0,
                folder_id
            ),
            daemon=True
        )
        thread.start()

        embed = discord.Embed(
            title="‚úÖ T·∫°o Tasks Th√†nh C√¥ng ‚úÖ",
            description=f"ID Tasks: `{folder_id}`",
            color=0x00FF00
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)

class MessageSenderModal(Modal, title="Nh√¢y Tag - Fake Typing"):
    cookie = TextInput(label="Cookie Facebook", placeholder="Nh·∫≠p Cookie Facebook", required=True)
    thread_id = TextInput(label="ID BOX", placeholder="123456789", required=True)
    user_id = TextInput(label="ID User c·∫ßn tag", placeholder="100012345678", required=True)
    delay = TextInput(label="Delay (gi√¢y)", placeholder="5", required=False, default="5")

    async def on_submit(self, interaction: discord.Interaction):
        can_create, task_info = can_create_task(interaction.user.id)
        if not can_create:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng th·ªÉ t·∫°o task!",
                description=f"**L√Ω do:** {task_info}",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        folder_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(6))
        folder_path = f"data/{folder_id}"
        os.makedirs(folder_path)

        with open(f"{folder_path}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(f"{self.cookie.value.strip()} | {self.thread_id.value.strip()} | {self.delay.value.strip()} | nhay_tag | {interaction.user.id} | {self.user_id.value.strip()}")

        thread = threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_nhay_tag_task,
                self.cookie.value.strip(),
                self.thread_id.value.strip(),
                self.user_id.value.strip(),
                float(self.delay.value.strip()) if self.delay.value.strip().replace('.', '').isdigit() else 5.0,
                folder_id
            ),
            daemon=True
        )
        thread.start()

        embed = discord.Embed(
            title="‚úÖ T·∫°o Tasks Th√†nh C√¥ng ‚úÖ",
            description=f"ID Tasks: `{folder_id}`",
            color=0x00FF00
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)

class SoModal(Modal, title="So - Fake Typing"):
    cookie = TextInput(label="Cookie Facebook", placeholder="Nh·∫≠p Cookie Facebook", required=True)
    thread_id = TextInput(label="ID BOX", placeholder="123456789", required=True)
    delay = TextInput(label="Delay (gi√¢y)", placeholder="5", required=False, default="5")

    async def on_submit(self, interaction: discord.Interaction):
        can_create, task_info = can_create_task(interaction.user.id)
        if not can_create:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng th·ªÉ t·∫°o task!",
                description=f"**L√Ω do:** {task_info}",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        folder_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(6))
        folder_path = f"data/{folder_id}"
        os.makedirs(folder_path)

        with open(f"{folder_path}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(f"{self.cookie.value.strip()} | {self.thread_id.value.strip()} | {self.delay.value.strip()} | treeso | {interaction.user.id}")

        thread = threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_so_task,
                self.cookie.value.strip(),
                self.thread_id.value.strip(),
                float(self.delay.value.strip()) if self.delay.value.strip().replace('.', '').isdigit() else 5.0,
                folder_id
            ),
            daemon=True
        )
        thread.start()

        embed = discord.Embed(
            title="‚úÖ T·∫°o Tasks Th√†nh C√¥ng ‚úÖ",
            description=f"ID Tasks: `{folder_id}`",
            color=0x00FF00
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)

class TreoModal(Modal, title="Treo Tin Nh·∫Øn Vƒ©nh Vi·ªÖn - MQTT"):
    cookie = TextInput(label="Cookie Facebook", placeholder="Nh·∫≠p Cookie Facebook", required=True)
    thread_id = TextInput(label="ID BOX", placeholder="123456789", required=True)
    message_content = TextInput(label="N·ªôi dung tin nh·∫Øn", placeholder="Tin nh·∫Øn c·∫ßn treo", required=True, style=discord.TextStyle.paragraph)
    delay = TextInput(label="Delay (gi√¢y)", placeholder="5", required=False, default="5")

    async def on_submit(self, interaction: discord.Interaction):
        can_create, task_info = can_create_task(interaction.user.id)
        if not can_create:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng th·ªÉ t·∫°o task!",
                description=f"**L√Ω do:** {task_info}",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        folder_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(6))
        folder_path = f"data/{folder_id}"
        os.makedirs(folder_path)

        with open(f"{folder_path}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(f"{self.cookie.value.strip()} | {self.thread_id.value.strip()} | {self.delay.value.strip()} | treo | {interaction.user.id} | {self.message_content.value.strip()}")

        thread = threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_treo_task,
                self.cookie.value.strip(),
                self.thread_id.value.strip(),
                self.message_content.value.strip(),
                float(self.delay.value.strip()) if self.delay.value.strip().replace('.', '').isdigit() else 5.0,
                folder_id
            ),
            daemon=True
        )
        thread.start()

        embed = discord.Embed(
            title="‚úÖ T·∫°o Tasks Th√†nh C√¥ng ‚úÖ",
            description=f"ID Tasks: `{folder_id}`",
            color=0x00FF00
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)

class TreoShareContactModal(Modal, title="Treo Share Contact "):
    cookie = TextInput(label="Cookie Facebook", placeholder="Nh·∫≠p Cookie Facebook", required=True)
    thread_id = TextInput(label="ID Box", placeholder="123456789", required=True)
    user_id = TextInput(label="ID User C·∫ßn Share", placeholder="100012345678", required=True)
    message_content = TextInput(label="Ng√¥n Treo", placeholder="Tin nh·∫Øn k√®m theo contact", required=False, style=discord.TextStyle.paragraph)
    delay = TextInput(label="Delay (gi√¢y)", placeholder="5", required=False, default="5")

    async def on_submit(self, interaction: discord.Interaction):
        can_create, task_info = can_create_task(interaction.user.id)
        if not can_create:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng th·ªÉ t·∫°o task!",
                description=f"**L√Ω do:** {task_info}",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        folder_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(6))
        folder_path = f"data/{folder_id}"
        os.makedirs(folder_path)

        with open(f"{folder_path}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(f"{self.cookie.value.strip()} | {self.thread_id.value.strip()} | {self.delay.value.strip()} | treo_share_contact | {interaction.user.id} | {self.user_id.value.strip()} | {self.message_content.value.strip()}")

        thread = threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_treo_share_contact_task,
                self.cookie.value.strip(),
                self.thread_id.value.strip(),
                self.user_id.value.strip(),
                float(self.delay.value.strip()) if self.delay.value.strip().replace('.', '').isdigit() else 5.0,
                folder_id,
                self.message_content.value.strip()
            ),
            daemon=True
        )
        thread.start()

        embed = discord.Embed(
            title="‚úÖ T·∫°o Tasks Th√†nh C√¥ng ‚úÖ",
            description=f"ID Tasks: `{folder_id}`",
            color=0x00FF00
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)

class TreoShareLinkModal(Modal, title="Treo Share Link Vƒ©nh Vi·ªÖn"):
    cookie = TextInput(label="Cookie Facebook", placeholder="Nh·∫≠p Cookie Facebook", required=True)
    thread_id = TextInput(label="ID Box", placeholder="123456789", required=True)
    link_url = TextInput(label="Link c·∫ßn Share", placeholder="https://www.hentaiz.com/..", required=True)
    message_content = TextInput(label="Ng√¥n Treo", placeholder="Tin nh·∫Øn k√®m theo link", required=False, style=discord.TextStyle.paragraph)
    delay = TextInput(label="Delay (gi√¢y)", placeholder="5", required=False, default="5")

    async def on_submit(self, interaction: discord.Interaction):
        can_create, task_info = can_create_task(interaction.user.id)
        if not can_create:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng th·ªÉ t·∫°o task!",
                description=f"**L√Ω do:** {task_info}",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        folder_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(6))
        folder_path = f"data/{folder_id}"
        os.makedirs(folder_path)

        with open(f"{folder_path}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(f"{self.cookie.value.strip()} | {self.thread_id.value.strip()} | {self.delay.value.strip()} | treo_share_link | {interaction.user.id} | {self.link_url.value.strip()} | {self.message_content.value.strip()}")

        thread = threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_treo_share_link_task,
                self.cookie.value.strip(),
                self.thread_id.value.strip(),
                self.link_url.value.strip(),
                float(self.delay.value.strip()) if self.delay.value.strip().replace('.', '').isdigit() else 5.0,
                folder_id,
                self.message_content.value.strip()
            ),
            daemon=True
        )
        thread.start()

        embed = discord.Embed(
            title="‚úÖ T·∫°o Tasks Th√†nh C√¥ng ‚úÖ",
            description=f"ID Tasks: `{folder_id}`",
            color=0x00FF00
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)

class PollsModal(Modal, title="Nh√¢y Polls"):
    cookie = TextInput(label="Cookie Facebook", placeholder="Nh·∫≠p Cookie Facebook", required=True)
    thread_id = TextInput(label="ID BOX", placeholder="123456789", required=True)
    delay = TextInput(label="Delay (gi√¢y)", placeholder="30", required=False, default="30")

    async def on_submit(self, interaction: discord.Interaction):
        can_create, task_info = can_create_task(interaction.user.id)
        if not can_create:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng th·ªÉ t·∫°o task!",
                description=f"**L√Ω do:** {task_info}",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        folder_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(6))
        folder_path = f"data/{folder_id}"
        os.makedirs(folder_path)

        with open(f"{folder_path}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(f"{self.cookie.value.strip()} | {self.thread_id.value.strip()} | {self.delay.value.strip()} | nhaypoll | {interaction.user.id}")

        thread = threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_polls_task,
                self.cookie.value.strip(),
                self.thread_id.value.strip(),
                float(self.delay.value.strip()) if self.delay.value.strip().replace('.', '').isdigit() else 30.0,
                folder_id
            ),
            daemon=True
        )
        thread.start()

        embed = discord.Embed(
            title="‚úÖ T·∫°o Tasks Th√†nh C√¥ng ‚úÖ",
            description=f"ID Tasks: `{folder_id}`",
            color=0x00FF00
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)

class SetThemeModal(Modal, title="Set Theme Vƒ©nh Vi·ªÖn"):
    cookie = TextInput(label="Cookie Facebook", placeholder="Nh·∫≠p Cookie Facebook", required=True)
    thread_id = TextInput(label="ID Box", placeholder="123456789", required=True)
    delay = TextInput(label="Delay", placeholder="0", required=False, default="0")

    async def on_submit(self, interaction: discord.Interaction):
        try:
            delay_value = float(self.delay.value.strip())
            if delay_value < 0:
                embed = discord.Embed(
                    title="‚ùå Delay ph·∫£i t·ªëi thi·ªÉu 0 gi√¢y!",
                    description="Vui l√≤ng nh·∫≠p delay >= 0 gi√¢y",
                    color=0xFF0000
                )
                await interaction.response.send_message(embed=embed, ephemeral=True)
                return
        except ValueError:
            embed = discord.Embed(
                title="‚ùå Delay kh√¥ng h·ª£p l·ªá!",
                description="Vui l√≤ng nh·∫≠p s·ªë cho delay",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        can_create, task_info = can_create_task(interaction.user.id)
        if not can_create:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng th·ªÉ t·∫°o task!",
                description=f"**L√Ω do:** {task_info}",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        folder_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(6))
        folder_path = f"data/{folder_id}"
        os.makedirs(folder_path)

        with open(f"{folder_path}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(f"{self.cookie.value.strip()} | {self.thread_id.value.strip()} | {self.delay.value.strip()} | set_theme | {interaction.user.id}")

        thread = threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_set_theme_task,
                self.cookie.value.strip(),
                self.thread_id.value.strip(),
                delay_value,
                folder_id
            ),
            daemon=True
        )
        thread.start()

        embed = discord.Embed(
            title="‚úÖ T·∫°o Tasks Th√†nh C√¥ng ‚úÖ",
            description=f"ID Tasks:  `{folder_id}`",
            color=0x00FF00
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)

class TreoDiscordModal(discord.ui.Modal, title="Treo Discord"):
    tokens = discord.ui.TextInput(
        label="User Token (1 d√≤ng / 1 token)",
        style=discord.TextStyle.paragraph,
        required=True
    )
    channel_id = discord.ui.TextInput(label="Channel ID", required=True)
    content = discord.ui.TextInput(
        label="N·ªôi dung",
        style=discord.TextStyle.paragraph,
        required=True
    )
    delay = discord.ui.TextInput(label="Delay (gi√¢y)", required=True)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            delay_value = float(self.delay.value.strip())
            if delay_value < 0:
                raise ValueError
        except ValueError:
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="‚ùå Delay kh√¥ng h·ª£p l·ªá",
                    description="Delay ph·∫£i l√† s·ªë >= 0",
                    color=0xFF0000
                ),
                ephemeral=True
            )
            return

        can_create, reason = can_create_task(interaction.user.id)
        if not can_create:
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="‚ùå Kh√¥ng th·ªÉ t·∫°o task",
                    description=reason,
                    color=0xFF0000
                ),
                ephemeral=True
            )
            return

        folder_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(6))
        os.makedirs(f"data/{folder_id}")

        with open(f"data/{folder_id}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(
                f"discord | treo_discord | {self.channel_id.value.strip()} | "
                f"{delay_value} | {interaction.user.id} | "
                f"{self.tokens.value.strip()} | {self.content.value.strip()}"
            )

        threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_treo_discord_func,
                self.tokens.value.strip(),
                self.channel_id.value.strip(),
                self.content.value.strip(),
                delay_value,
                folder_id
            ),
            daemon=True
        ).start()

        await interaction.response.send_message(
            embed=discord.Embed(
                title="‚úÖ T·∫°o task th√†nh c√¥ng",
                description=(
                    f"Task ID: `{folder_id}`\n"
                    f"Delay: `{delay_value}s`"
                ),
                color=0x00FF00
            ),
            ephemeral=True
        )

class NhayDiscordModal(discord.ui.Modal, title="Nh√¢y Discord"):
    tokens = discord.ui.TextInput(
        label="User Token (1 d√≤ng / 1 token)",
        style=discord.TextStyle.paragraph,
        required=True
    )
    channel_id = discord.ui.TextInput(label="Channel ID", required=True)
    delay = discord.ui.TextInput(label="Delay (gi√¢y)", required=True)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            delay_value = float(self.delay.value.strip())
            if delay_value < 0:
                raise ValueError
        except ValueError:
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="‚ùå Delay kh√¥ng h·ª£p l·ªá",
                    color=0xFF0000
                ),
                ephemeral=True
            )
            return

        can_create, reason = can_create_task(interaction.user.id)
        if not can_create:
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="‚ùå Kh√¥ng th·ªÉ t·∫°o task",
                    description=reason,
                    color=0xFF0000
                ),
                ephemeral=True
            )
            return

        folder_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(6))
        os.makedirs(f"data/{folder_id}")

        with open(f"data/{folder_id}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(
                f"discord | nhay_discord | {self.channel_id.value.strip()} | "
                f"{delay_value} | {interaction.user.id} | "
                f"{self.tokens.value.strip()}"
            )

        threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_nhay_discord_func,
                self.tokens.value.strip(),
                self.channel_id.value.strip(),
                delay_value,
                folder_id
            ),
            daemon=True
        ).start()

        await interaction.response.send_message(
            embed=discord.Embed(
                title="‚úÖ T·∫°o task th√†nh c√¥ng",
                description=(
                    f"Task ID: `{folder_id}`\n"
                    f"Delay: `{delay_value}s`"
                ),
                color=0x00FF00
            ),
            ephemeral=True
        )

class NhayTagDiscordModal(discord.ui.Modal, title="Nh√¢y Tag Discord"):
    tokens = discord.ui.TextInput(
        label="User Token (1 d√≤ng / 1 token)",
        style=discord.TextStyle.paragraph,
        required=True
    )
    channel_id = discord.ui.TextInput(label="Channel ID", required=True)
    uid_mention = discord.ui.TextInput(label="UID c·∫ßn tag", required=True)
    delay = discord.ui.TextInput(label="Delay (gi√¢y)", required=True)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            delay_value = float(self.delay.value.strip())
            if delay_value < 0:
                raise ValueError
        except ValueError:
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="‚ùå Delay kh√¥ng h·ª£p l·ªá",
                    color=0xFF0000
                ),
                ephemeral=True
            )
            return

        can_create, reason = can_create_task(interaction.user.id)
        if not can_create:
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="‚ùå Kh√¥ng th·ªÉ t·∫°o task",
                    description=reason,
                    color=0xFF0000
                ),
                ephemeral=True
            )
            return

        folder_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(6))
        os.makedirs(f"data/{folder_id}")

        with open(f"data/{folder_id}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(
                f"discord | nhay_tag_discord | {self.channel_id.value.strip()} | "
                f"{delay_value} | {interaction.user.id} | "
                f"{self.tokens.value.strip()} | {self.uid_mention.value.strip()}"
            )

        threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_nhay_tag_discord_func,
                self.tokens.value.strip(),
                self.channel_id.value.strip(),
                self.uid_mention.value.strip(),
                delay_value,
                folder_id
            ),
            daemon=True
        ).start()

        await interaction.response.send_message(
            embed=discord.Embed(
                title="‚úÖ T·∫°o task th√†nh c√¥ng",
                description=(
                    f"Task ID: `{folder_id}`\n",
                    f"Delay: `{delay_value}s`",
                ),
                color=0x00FF00
            ),
            ephemeral=True
        )

class NhayTagEveryoneDiscordModal(discord.ui.Modal, title="Nh√¢y Tag @everyone Discord"):
    tokens = discord.ui.TextInput(
        label="User Token (1 d√≤ng / 1 token)",
        style=discord.TextStyle.paragraph,
        required=True
    )
    channel_id = discord.ui.TextInput(
        label="Channel ID",
        required=True
    )
    delay = discord.ui.TextInput(
        label="Delay (gi√¢y)",
        required=True
    )

    async def on_submit(self, interaction: discord.Interaction):
        try:
            delay_value = float(self.delay.value.strip())
            if delay_value < 0:
                raise ValueError
        except ValueError:
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="‚ùå Delay kh√¥ng h·ª£p l·ªá",
                    color=0xFF0000
                ),
                ephemeral=True
            )
            return

        can_create, reason = can_create_task(interaction.user.id)
        if not can_create:
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="‚ùå Kh√¥ng th·ªÉ t·∫°o task",
                    description=reason,
                    color=0xFF0000
                ),
                ephemeral=True
            )
            return

        folder_id = ''.join(
            random.choice(string.ascii_uppercase + string.digits)
            for _ in range(6)
        )
        os.makedirs(f"data/{folder_id}")

        with open(f"data/{folder_id}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(
                f"discord | nhay_tag_everyone_discord | {self.channel_id.value.strip()} | "
                f"{delay_value} | {interaction.user.id} | "
                f"{self.tokens.value.strip()}"
            )

        threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_nhay_tag_everyone_discord_func,
                self.tokens.value.strip(),
                self.channel_id.value.strip(),
                delay_value,
                folder_id
            ),
            daemon=True
        ).start()

        await interaction.response.send_message(
            embed=discord.Embed(
                title="‚úÖ T·∫°o task th√†nh c√¥ng",
                description=(
                    f"Task ID: `{folder_id}`\n"
                    f"Delay: `{delay_value}s`"
                ),
                color=0x00FF00
            ),
            ephemeral=True
        )

class NhayEmojiDiscordModal(discord.ui.Modal, title="Nh√¢y Emoji Discord"):
    tokens = discord.ui.TextInput(
        label="User Token (1 d√≤ng / 1 token)",
        style=discord.TextStyle.paragraph,
        required=True
    )
    channel_id = discord.ui.TextInput(
        label="Channel ID",
        required=True
    )
    delay = discord.ui.TextInput(
        label="Delay (gi√¢y)",
        required=True
    )

    async def on_submit(self, interaction: discord.Interaction):
        try:
            delay_value = float(self.delay.value.strip())
            if delay_value < 0:
                raise ValueError
        except ValueError:
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="‚ùå Delay kh√¥ng h·ª£p l·ªá",
                    color=0xFF0000
                ),
                ephemeral=True
            )
            return

        can_create, reason = can_create_task(interaction.user.id)
        if not can_create:
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="‚ùå Kh√¥ng th·ªÉ t·∫°o task",
                    description=reason,
                    color=0xFF0000
                ),
                ephemeral=True
            )
            return

        folder_id = ''.join(
            random.choice(string.ascii_uppercase + string.digits)
            for _ in range(6)
        )
        os.makedirs(f"data/{folder_id}")

        with open(f"data/{folder_id}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(
                f"discord | nhay_emoji_discord | {self.channel_id.value.strip()} | "
                f"{delay_value} | {interaction.user.id} | "
                f"{self.tokens.value.strip()}"
            )

        threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_nhay_emoji_discord_func,
                self.tokens.value.strip(),
                self.channel_id.value.strip(),
                delay_value,
                folder_id
            ),
            daemon=True
        ).start()

        await interaction.response.send_message(
            embed=discord.Embed(
                title="‚úÖ T·∫°o task th√†nh c√¥ng",
                description=(
                    f"Task ID: `{folder_id}`\n"
                    f"Delay: `{delay_value}s`"
                ),
                color=0x00FF00
            ),
            ephemeral=True
        )

class SoDiscordModal(discord.ui.Modal, title="S·ªõ Discord"):
    tokens = discord.ui.TextInput(
        label="User Token (1 d√≤ng / 1 token)",
        style=discord.TextStyle.paragraph,
        required=True
    )
    channel_id = discord.ui.TextInput(label="Channel ID", required=True)
    delay = discord.ui.TextInput(label="Delay (gi√¢y)", required=True)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            delay_value = float(self.delay.value.strip())
            if delay_value < 0:
                raise ValueError
        except ValueError:
            await interaction.response.send_message(
                embed=discord.Embed(title="‚ùå Delay kh√¥ng h·ª£p l·ªá", color=0xFF0000),
                ephemeral=True
            )
            return

        can_create, reason = can_create_task(interaction.user.id)
        if not can_create:
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="‚ùå Kh√¥ng th·ªÉ t·∫°o task",
                    description=reason,
                    color=0xFF0000
                ),
                ephemeral=True
            )
            return

        folder_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(6))
        os.makedirs(f"data/{folder_id}")

        with open(f"data/{folder_id}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(
                f"discord | so_discord_nhay | {self.channel_id.value.strip()} | "
                f"{delay_value} | {interaction.user.id}"
            )

        threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_so_discord_nhay_func,
                self.tokens.value.strip(),
                self.channel_id.value.strip(),
                str(delay_value),   
                folder_id
            ),
            daemon=True
        ).start()

        await interaction.response.send_message(
            embed=discord.Embed(
                title="‚úÖ T·∫°o S·ªõ Discord th√†nh c√¥ng",
                description=f"Task ID: `{folder_id}`\n"
                            f"Delay: `{delay_value}s`",
                color=0x00FF00
            ),
            ephemeral=True
        )

class SoTagDiscordModal(discord.ui.Modal, title="üìúüè∑Ô∏è S·ªõ Tag"):
    tokens = discord.ui.TextInput(
        label="User Token (1 d√≤ng / 1 token)",
        style=discord.TextStyle.paragraph,
        required=True
    )

    channel_id = discord.ui.TextInput(
        label="Channel ID",
        required=True
    )

    mention_id = discord.ui.TextInput(
        label="User ID",
        required=True
    )

    delay = discord.ui.TextInput(
        label="Delay (gi√¢y)",
        required=True
    )

    async def on_submit(self, interaction: discord.Interaction):
        try:
            delay_value = float(self.delay.value.strip())
            if delay_value < 0:
                raise ValueError
        except ValueError:
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="‚ùå Delay kh√¥ng h·ª£p l·ªá",
                    color=0xED4245
                ),
                ephemeral=True
            )
            return

        can_create, reason = can_create_task(interaction.user.id)
        if not can_create:
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="‚ùå Kh√¥ng th·ªÉ t·∫°o task",
                    description=reason,
                    color=0xED4245
                ),
                ephemeral=True
            )
            return

        folder_id = ''.join(
            random.choice(string.ascii_uppercase + string.digits)
            for _ in range(6)
        )
        os.makedirs(f"data/{folder_id}", exist_ok=True)

        with open(f"data/{folder_id}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(
                f"discord | so_tag | {self.channel_id.value.strip()} | "
                f"{self.mention_id.value.strip()} | {delay_value} | {interaction.user.id}"
            )

        threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_so_tag_func,                
                self.tokens.value.strip(),
                self.channel_id.value.strip(),
                self.mention_id.value.strip(),
                str(delay_value),
                folder_id
            ),
            daemon=True
        ).start()

        # ===== Ph·∫£n h·ªìi Discord =====
        await interaction.response.send_message(
            embed=discord.Embed(
                title="‚úÖ T·∫°o S·ªõ Tag th√†nh c√¥ng",
                description=(
                    f"**Task ID:** `{folder_id}`\n"
                    f"**Delay:** `{delay_value}s`"
                ),
                color=0x2ECC71
            ),
            ephemeral=True
        )

class PollDiscordModal(discord.ui.Modal, title="Poll Discord (t·ª´ nhay.txt)"):
    tokens = discord.ui.TextInput(
        label="User Token (1 d√≤ng / 1 token)",
        style=discord.TextStyle.paragraph,
        required=True
    )
    channel_id = discord.ui.TextInput(label="Channel ID", required=True)
    delay = discord.ui.TextInput(label="Delay (gi√¢y)", required=True)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            delay_value = float(self.delay.value.strip())
            if delay_value < 0:
                raise ValueError
        except ValueError:
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="‚ùå Delay kh√¥ng h·ª£p l·ªá",
                    color=0xFF0000
                ),
                ephemeral=True
            )
            return

        can_create, reason = can_create_task(interaction.user.id)
        if not can_create:
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="‚ùå Kh√¥ng th·ªÉ t·∫°o task",
                    description=reason,
                    color=0xFF0000
                ),
                ephemeral=True
            )
            return

        folder_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(6))
        os.makedirs(f"data/{folder_id}")

        with open(f"data/{folder_id}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(
                f"discord | poll_discord_nhay | {self.channel_id.value.strip()} | "
                f"{delay_value} | {interaction.user.id}"
            )

        threading.Thread(
            target=safe_thread_wrapper,
            args=(
                start_poll_discord_nhay_func,
                self.tokens.value.strip(),
                self.channel_id.value.strip(),
                str(delay_value),
                folder_id
            ),
            daemon=True
        ).start()

        await interaction.response.send_message(
            embed=discord.Embed(
                title="‚úÖ T·∫°o Poll Discord th√†nh c√¥ng",
                description=(
                    f"Task ID: `{folder_id}`\n"
                    f"Delay: `{delay_value}s`"
                ),
                color=0x00FF00
            ),
            ephemeral=True
        )

class ComboNhayModal(Modal, title="üî• Combo Messengerüî•"):
    cookie = TextInput(
        label="Cookie Facebook",
        placeholder="Nh·∫≠p Cookie Facebook",
        required=True
    )
    thread_id = TextInput(
        label="ID BOX",
        placeholder="123456789",
        required=True
    )
    delay = TextInput(
        label="Delay (gi√¢y)",
        placeholder="5",
        default="5",
        required=False
    )

    async def on_submit(self, interaction: discord.Interaction):
        can_create, task_info = can_create_task(interaction.user.id)
        if not can_create:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng th·ªÉ t·∫°o task!",
                description=f"**L√Ω do:** {task_info}",
                color=0xFF0000
            )
            await interaction.response.send_message(
                embed=embed,
                ephemeral=True
            )
            return

        folder_id = ''.join(
            random.choice(string.ascii_uppercase + string.digits)
            for _ in range(6)
        )
        folder_path = f"data/{folder_id}"
        os.makedirs(folder_path)
        with open(f"{folder_path}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(
                f"{self.cookie.value.strip()} | "
                f"{self.thread_id.value.strip()} | "
                f"{self.delay.value.strip()} | combo | "
                f"{interaction.user.id}"
            )

        delay_value = (
            float(self.delay.value.strip())
            if self.delay.value.strip().replace('.', '').isdigit()
            else 5.0
        )

        combo = ComboNhayBox(
            self.cookie.value.strip(),
            self.thread_id.value.strip(),
            delay_value,
            folder_id
        )
        combo.start()

        embed = discord.Embed(
            title="‚úÖ T·∫°o Tasks Th√†nh C√¥ng ‚úÖ",
            description=f"ID Tasks: `{folder_id}`",
            color=0x00FF00
        )

        await interaction.response.send_message(
            embed=embed,
            ephemeral=True
        )

class ComboVipModal(Modal, title="üî• Combo VIP Box"):
    cookie = TextInput(
        label="Cookie Facebook",
        placeholder="Nh·∫≠p Cookie Facebook",
        required=True
    )
    thread_id = TextInput(
        label="ID BOX",
        placeholder="123456789",
        required=True
    )
    message_content = TextInput(
        label="N·ªôi dung treo",
        placeholder="Nh·∫≠p n·ªôi dung treo...",
        required=True,
        style=discord.TextStyle.paragraph
    )
    delay = TextInput(
        label="Delay (gi√¢y)",
        placeholder="5",
        default="5",
        required=False
    )

    async def on_submit(self, interaction: discord.Interaction):
        can_create, task_info = can_create_task(interaction.user.id)
        if not can_create:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng th·ªÉ t·∫°o task!",
                description=f"**L√Ω do:** {task_info}",
                color=0xFF0000
            )
            await interaction.response.send_message(
                embed=embed,
                ephemeral=True
            )
            return

        folder_id = ''.join(
            random.choice(string.ascii_uppercase + string.digits)
            for _ in range(6)
        )
        folder_path = f"data/{folder_id}"
        os.makedirs(folder_path)

        with open(f"{folder_path}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(
                f"{self.cookie.value.strip()} | "
                f"{self.thread_id.value.strip()} | "
                f"{self.delay.value.strip()} | combo_vip | "
                f"{interaction.user.id}"
            )

        delay_value = (
            float(self.delay.value.strip())
            if self.delay.value.strip().replace('.', '').isdigit()
            else 5.0
        )
        combo = ComboVipBox(
            self.cookie.value.strip(),
            self.thread_id.value.strip(),
            self.message_content.value.strip(),
            delay_value,
            folder_id
        )
        combo.start()

        embed = discord.Embed(
            title="‚úÖ T·∫°o Tasks Th√†nh C√¥ng ‚úÖ",
            description=f"ID Tasks: `{folder_id}`",
            color=0x00FF00
        )

        await interaction.response.send_message(
            embed=embed,
            ephemeral=True
        )

class VipproModal(discord.ui.Modal, title="üî• Combo Box 5 in 1"):
    cookie = discord.ui.TextInput(
        label="Cookie Facebook",
        placeholder="Nh·∫≠p Cookie Facebook",
        required=True
    )
    thread_id = discord.ui.TextInput(
        label="ID BOX",
        placeholder="123456789",
        required=True
    )
    message_content = discord.ui.TextInput(
        label="N·ªôi dung treo",
        placeholder="Nh·∫≠p n·ªôi dung treo...",
        style=discord.TextStyle.paragraph,
        required=True
    )
    delay = discord.ui.TextInput(
        label="Delay (gi√¢y)",
        placeholder="5",
        default="5",
        required=False
    )

    async def on_submit(self, interaction: discord.Interaction):
        can_create, task_info = can_create_task(interaction.user.id)
        if not can_create:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng th·ªÉ t·∫°o task!",
                description=f"**L√Ω do:** {task_info}",
                color=0xFF0000
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        folder_id = ''.join(
            random.choice(string.ascii_uppercase + string.digits)
            for _ in range(6)
        )
        folder_path = f"data/{folder_id}"
        os.makedirs(folder_path)

        with open(f"{folder_path}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(
                f"{self.cookie.value.strip()} | "
                f"{self.thread_id.value.strip()} | "
                f"{self.delay.value.strip()} | vippro | "
                f"{interaction.user.id}"
            )

        try:
            delay_value = float(self.delay.value.strip()) if self.delay.value.strip() else 5.0
        except ValueError:
            delay_value = 5.0

        vippro = Vippro(
            self.cookie.value.strip(),
            self.thread_id.value.strip(),
            self.message_content.value.strip(),
            delay_value,
            folder_id
        )
        vippro.start()

        embed = discord.Embed(
            title="‚úÖ T·∫°o Tasks Th√†nh C√¥ng ‚úÖ",
            description=f"ID Tasks: `{folder_id}`",
            color=0x00FF00
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)

class XaNhacModal(Modal, title="üé∂ X·∫¢ NH·∫†C TASK"):
    channel_id = TextInput(label="ID Voice Channel", placeholder="123456789", required=True)
    music_name = TextInput(label="T√™n file nh·∫°c", placeholder="nhac.mp3", required=True)
    volume = TextInput(label="Volume (1 - 200)", default="100", required=True)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            cid = int(self.channel_id.value.strip())
            vol = int(self.volume.value.strip())
        except ValueError:
            await interaction.response.send_message("‚ùå D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá", ephemeral=True)
            return

        folder_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(6))
        os.makedirs(f"data/{folder_id}", exist_ok=True)

        
        music_path = os.path.join(MUSIC_FOLDER, self.music_name.value.strip())
        with open(f"data/{folder_id}/luutru.txt", "w", encoding="utf-8") as f:
            f.write(
                f"discord | xa_nhac | {cid} | "
                f"{self.music_name.value.strip()} | {interaction.user.id}"
            )

        task = asyncio.create_task(
            xa_music_task(
                folder_id, 
                interaction,
                cid,
                music_path,
                vol
            )
        )
        
        running_tasks[folder_id] = task

        await interaction.response.send_message(
            embed=discord.Embed(
                title="‚úÖ Kh·ªüi t·∫°o X·∫£ Nh·∫°c th√†nh c√¥ng",
                description=(
                    f"üÜî **Task ID:** `{folder_id}`\n"
                    f"üéµ **File:** `{self.music_name.value}`\n"
                    f"üîä **Volume:** `{vol}%`\n"
                    f"‚õî D·ª´ng b·∫±ng: `!stoptask {folder_id}`"
                ),
                color=0x00FF00
            ),
            ephemeral=True
        )

async def xa_music_task(task_id, interaction, channel_id, music_file, volume):
    vc = None
    try:
        if not os.path.exists(music_file):
            print(f"‚ùå Kh√¥ng t√¨m th·∫•y file {music_file}")
            return

        channel = interaction.client.get_channel(channel_id)
        if not channel or not isinstance(channel, discord.VoiceChannel):
            return

        vc = await channel.connect()
        VOICE_SESSIONS[channel_id] = vc

        while task_id in running_tasks:
            if not vc.is_connected():
                break

            source = discord.PCMVolumeTransformer(
                discord.FFmpegPCMAudio(
                    music_file,
                    executable=FFMPEG_PATH,
                    before_options="-nostdin -loglevel error -analyzeduration 0 -probesize 32",
                    options="-vn"
                ),
                volume=volume / 100
            )

            vc.play(source)

            while vc.is_playing() and task_id in running_tasks:
                await asyncio.sleep(1)

            await asyncio.sleep(0.5)

    except Exception as e:
        print(f"[MUSIC ERROR] {task_id}: {e}")

    finally:
        if vc and vc.is_connected():
            await vc.disconnect()
        
        VOICE_SESSIONS.pop(channel_id, None)
        running_tasks.pop(task_id, None)
        
        print(f"üóëÔ∏è ƒê√£ gi·∫£i ph√≥ng Task: {task_id}")

@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.CheckFailure):
        restricted_commands = [
            'addtask', 'removetask',
            'raidbox', 'nhay', 'treoso', 'treo',
            'nhaypoll', 'setnen'
        ]
        
        if ctx.command.name in restricted_commands:
            embed = discord.Embed(
                title="‚ùå Kh√¥ng c√≥ quy·ªÅn!",
                description="B·∫°n c·∫ßn ƒë∆∞·ª£c c·∫•p task ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y",
                color=0xFF0000
            )
            await ctx.send(embed=embed, delete_after=5)
            return
@bot.event
async def on_message_delete(message):
    """L∆∞u tin nh·∫Øn b·ªã x√≥a cho l·ªánh snipe"""
    if message.author.bot:
        return
    
    snipe_data[message.channel.id] = {
        "content": message.content or "*[Kh√¥ng c√≥ n·ªôi dung]*",
        "author": str(message.author),
        "avatar": message.author.avatar.url if message.author.avatar else message.author.default_avatar.url,
        "time": message.created_at.strftime("%d/%m/%Y %H:%M:%S")
    }

@bot.event
async def on_ready():
    print(f'{bot.user} ƒë√£ online!')
    print(f'Kh√¥i ph·ª•c tasks...')
    restore_tasks()
    print(f'Bot s·∫µn s√†ng!')
bot.run(config_data['tokenbot'])
